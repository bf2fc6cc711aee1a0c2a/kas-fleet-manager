// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package ocm

import (
	"context"
	"sync"
)

// Ensure, that authorizationMock does implement OCMAuthorization.
// If this is not the case, regenerate this file with moq.
var _ OCMAuthorization = &authorizationMock{}

// authorizationMock is a mock implementation of OCMAuthorization.
//
// 	func TestSomethingThatUsesOCMAuthorization(t *testing.T) {
//
// 		// make and configure a mocked OCMAuthorization
// 		mockedOCMAuthorization := &authorizationMock{
// 			AccessReviewFunc: func(ctx context.Context, username string, action string, resourceType string, organizationID string, subscriptionID string, clusterID string) (bool, error) {
// 				panic("mock out the AccessReview method")
// 			},
// 			GetUserIdFunc: func(ctx context.Context) (string, error) {
// 				panic("mock out the GetUserId method")
// 			},
// 			IsUserHasValidSubsFunc: func(ctx context.Context) (bool, error) {
// 				panic("mock out the IsUserHasValidSubs method")
// 			},
// 			ListKafkaClusterWithActiveSubscriptionFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the ListKafkaClusterWithActiveSubscription method")
// 			},
// 			SelfAccessReviewFunc: func(ctx context.Context, action string, resourceType string, organizationID string, subscriptionID string, clusterID string) (bool, error) {
// 				panic("mock out the SelfAccessReview method")
// 			},
// 		}
//
// 		// use mockedOCMAuthorization in code that requires OCMAuthorization
// 		// and then make assertions.
//
// 	}
type authorizationMock struct {
	// AccessReviewFunc mocks the AccessReview method.
	AccessReviewFunc func(ctx context.Context, username string, action string, resourceType string, organizationID string, subscriptionID string, clusterID string) (bool, error)

	// GetUserIdFunc mocks the GetUserId method.
	GetUserIdFunc func(ctx context.Context) (string, error)

	// IsUserHasValidSubsFunc mocks the IsUserHasValidSubs method.
	IsUserHasValidSubsFunc func(ctx context.Context) (bool, error)

	// ListKafkaClusterWithActiveSubscriptionFunc mocks the ListKafkaClusterWithActiveSubscription method.
	ListKafkaClusterWithActiveSubscriptionFunc func(ctx context.Context) ([]string, error)

	// SelfAccessReviewFunc mocks the SelfAccessReview method.
	SelfAccessReviewFunc func(ctx context.Context, action string, resourceType string, organizationID string, subscriptionID string, clusterID string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// AccessReview holds details about calls to the AccessReview method.
		AccessReview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// Action is the action argument value.
			Action string
			// ResourceType is the resourceType argument value.
			ResourceType string
			// OrganizationID is the organizationID argument value.
			OrganizationID string
			// SubscriptionID is the subscriptionID argument value.
			SubscriptionID string
			// ClusterID is the clusterID argument value.
			ClusterID string
		}
		// GetUserId holds details about calls to the GetUserId method.
		GetUserId []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// IsUserHasValidSubs holds details about calls to the IsUserHasValidSubs method.
		IsUserHasValidSubs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListKafkaClusterWithActiveSubscription holds details about calls to the ListKafkaClusterWithActiveSubscription method.
		ListKafkaClusterWithActiveSubscription []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SelfAccessReview holds details about calls to the SelfAccessReview method.
		SelfAccessReview []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Action is the action argument value.
			Action string
			// ResourceType is the resourceType argument value.
			ResourceType string
			// OrganizationID is the organizationID argument value.
			OrganizationID string
			// SubscriptionID is the subscriptionID argument value.
			SubscriptionID string
			// ClusterID is the clusterID argument value.
			ClusterID string
		}
	}
	lockAccessReview                           sync.RWMutex
	lockGetUserId                              sync.RWMutex
	lockIsUserHasValidSubs                     sync.RWMutex
	lockListKafkaClusterWithActiveSubscription sync.RWMutex
	lockSelfAccessReview                       sync.RWMutex
}

// AccessReview calls AccessReviewFunc.
func (mock *authorizationMock) AccessReview(ctx context.Context, username string, action string, resourceType string, organizationID string, subscriptionID string, clusterID string) (bool, error) {
	if mock.AccessReviewFunc == nil {
		panic("authorizationMock.AccessReviewFunc: method is nil but OCMAuthorization.AccessReview was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Username       string
		Action         string
		ResourceType   string
		OrganizationID string
		SubscriptionID string
		ClusterID      string
	}{
		Ctx:            ctx,
		Username:       username,
		Action:         action,
		ResourceType:   resourceType,
		OrganizationID: organizationID,
		SubscriptionID: subscriptionID,
		ClusterID:      clusterID,
	}
	mock.lockAccessReview.Lock()
	mock.calls.AccessReview = append(mock.calls.AccessReview, callInfo)
	mock.lockAccessReview.Unlock()
	return mock.AccessReviewFunc(ctx, username, action, resourceType, organizationID, subscriptionID, clusterID)
}

// AccessReviewCalls gets all the calls that were made to AccessReview.
// Check the length with:
//     len(mockedOCMAuthorization.AccessReviewCalls())
func (mock *authorizationMock) AccessReviewCalls() []struct {
	Ctx            context.Context
	Username       string
	Action         string
	ResourceType   string
	OrganizationID string
	SubscriptionID string
	ClusterID      string
} {
	var calls []struct {
		Ctx            context.Context
		Username       string
		Action         string
		ResourceType   string
		OrganizationID string
		SubscriptionID string
		ClusterID      string
	}
	mock.lockAccessReview.RLock()
	calls = mock.calls.AccessReview
	mock.lockAccessReview.RUnlock()
	return calls
}

// GetUserId calls GetUserIdFunc.
func (mock *authorizationMock) GetUserId(ctx context.Context) (string, error) {
	if mock.GetUserIdFunc == nil {
		panic("authorizationMock.GetUserIdFunc: method is nil but OCMAuthorization.GetUserId was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetUserId.Lock()
	mock.calls.GetUserId = append(mock.calls.GetUserId, callInfo)
	mock.lockGetUserId.Unlock()
	return mock.GetUserIdFunc(ctx)
}

// GetUserIdCalls gets all the calls that were made to GetUserId.
// Check the length with:
//     len(mockedOCMAuthorization.GetUserIdCalls())
func (mock *authorizationMock) GetUserIdCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetUserId.RLock()
	calls = mock.calls.GetUserId
	mock.lockGetUserId.RUnlock()
	return calls
}

// IsUserHasValidSubs calls IsUserHasValidSubsFunc.
func (mock *authorizationMock) IsUserHasValidSubs(ctx context.Context) (bool, error) {
	if mock.IsUserHasValidSubsFunc == nil {
		panic("authorizationMock.IsUserHasValidSubsFunc: method is nil but OCMAuthorization.IsUserHasValidSubs was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockIsUserHasValidSubs.Lock()
	mock.calls.IsUserHasValidSubs = append(mock.calls.IsUserHasValidSubs, callInfo)
	mock.lockIsUserHasValidSubs.Unlock()
	return mock.IsUserHasValidSubsFunc(ctx)
}

// IsUserHasValidSubsCalls gets all the calls that were made to IsUserHasValidSubs.
// Check the length with:
//     len(mockedOCMAuthorization.IsUserHasValidSubsCalls())
func (mock *authorizationMock) IsUserHasValidSubsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockIsUserHasValidSubs.RLock()
	calls = mock.calls.IsUserHasValidSubs
	mock.lockIsUserHasValidSubs.RUnlock()
	return calls
}

// ListKafkaClusterWithActiveSubscription calls ListKafkaClusterWithActiveSubscriptionFunc.
func (mock *authorizationMock) ListKafkaClusterWithActiveSubscription(ctx context.Context) ([]string, error) {
	if mock.ListKafkaClusterWithActiveSubscriptionFunc == nil {
		panic("authorizationMock.ListKafkaClusterWithActiveSubscriptionFunc: method is nil but OCMAuthorization.ListKafkaClusterWithActiveSubscription was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListKafkaClusterWithActiveSubscription.Lock()
	mock.calls.ListKafkaClusterWithActiveSubscription = append(mock.calls.ListKafkaClusterWithActiveSubscription, callInfo)
	mock.lockListKafkaClusterWithActiveSubscription.Unlock()
	return mock.ListKafkaClusterWithActiveSubscriptionFunc(ctx)
}

// ListKafkaClusterWithActiveSubscriptionCalls gets all the calls that were made to ListKafkaClusterWithActiveSubscription.
// Check the length with:
//     len(mockedOCMAuthorization.ListKafkaClusterWithActiveSubscriptionCalls())
func (mock *authorizationMock) ListKafkaClusterWithActiveSubscriptionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListKafkaClusterWithActiveSubscription.RLock()
	calls = mock.calls.ListKafkaClusterWithActiveSubscription
	mock.lockListKafkaClusterWithActiveSubscription.RUnlock()
	return calls
}

// SelfAccessReview calls SelfAccessReviewFunc.
func (mock *authorizationMock) SelfAccessReview(ctx context.Context, action string, resourceType string, organizationID string, subscriptionID string, clusterID string) (bool, error) {
	if mock.SelfAccessReviewFunc == nil {
		panic("authorizationMock.SelfAccessReviewFunc: method is nil but OCMAuthorization.SelfAccessReview was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Action         string
		ResourceType   string
		OrganizationID string
		SubscriptionID string
		ClusterID      string
	}{
		Ctx:            ctx,
		Action:         action,
		ResourceType:   resourceType,
		OrganizationID: organizationID,
		SubscriptionID: subscriptionID,
		ClusterID:      clusterID,
	}
	mock.lockSelfAccessReview.Lock()
	mock.calls.SelfAccessReview = append(mock.calls.SelfAccessReview, callInfo)
	mock.lockSelfAccessReview.Unlock()
	return mock.SelfAccessReviewFunc(ctx, action, resourceType, organizationID, subscriptionID, clusterID)
}

// SelfAccessReviewCalls gets all the calls that were made to SelfAccessReview.
// Check the length with:
//     len(mockedOCMAuthorization.SelfAccessReviewCalls())
func (mock *authorizationMock) SelfAccessReviewCalls() []struct {
	Ctx            context.Context
	Action         string
	ResourceType   string
	OrganizationID string
	SubscriptionID string
	ClusterID      string
} {
	var calls []struct {
		Ctx            context.Context
		Action         string
		ResourceType   string
		OrganizationID string
		SubscriptionID string
		ClusterID      string
	}
	mock.lockSelfAccessReview.RLock()
	calls = mock.calls.SelfAccessReview
	mock.lockSelfAccessReview.RUnlock()
	return calls
}
