// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	apiErrors "github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/errors"
	"sync"
)

// Ensure, that QuotaServiceMock does implement QuotaService.
// If this is not the case, regenerate this file with moq.
var _ QuotaService = &QuotaServiceMock{}

// QuotaServiceMock is a mock implementation of QuotaService.
//
// 	func TestSomethingThatUsesQuotaService(t *testing.T) {
//
// 		// make and configure a mocked QuotaService
// 		mockedQuotaService := &QuotaServiceMock{
// 			DeleteQuotaFunc: func(id string) *apiErrors.ServiceError {
// 				panic("mock out the DeleteQuota method")
// 			},
// 			IsQuotaReservedFunc: func(productID string, orgID string) (bool, *apiErrors.ServiceError) {
// 				panic("mock out the IsQuotaReserved method")
// 			},
// 			ListReservedKafkaQuotaFunc: func(productID string, orgID string) ([]string, *apiErrors.ServiceError) {
// 				panic("mock out the ListReservedKafkaQuota method")
// 			},
// 			ReserveQuotaFunc: func(productID string, clusterID string, kafkaID string, owner string, reserve bool, availability string) (bool, string, *apiErrors.ServiceError) {
// 				panic("mock out the ReserveQuota method")
// 			},
// 		}
//
// 		// use mockedQuotaService in code that requires QuotaService
// 		// and then make assertions.
//
// 	}
type QuotaServiceMock struct {
	// DeleteQuotaFunc mocks the DeleteQuota method.
	DeleteQuotaFunc func(id string) *apiErrors.ServiceError

	// IsQuotaReservedFunc mocks the IsQuotaReserved method.
	IsQuotaReservedFunc func(productID string, orgID string) (bool, *apiErrors.ServiceError)

	// ListReservedKafkaQuotaFunc mocks the ListReservedKafkaQuota method.
	ListReservedKafkaQuotaFunc func(productID string, orgID string) ([]string, *apiErrors.ServiceError)

	// ReserveQuotaFunc mocks the ReserveQuota method.
	ReserveQuotaFunc func(productID string, clusterID string, kafkaID string, owner string, reserve bool, availability string) (bool, string, *apiErrors.ServiceError)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteQuota holds details about calls to the DeleteQuota method.
		DeleteQuota []struct {
			// ID is the id argument value.
			ID string
		}
		// IsQuotaReserved holds details about calls to the IsQuotaReserved method.
		IsQuotaReserved []struct {
			// ProductID is the productID argument value.
			ProductID string
			// OrgID is the orgID argument value.
			OrgID string
		}
		// ListReservedKafkaQuota holds details about calls to the ListReservedKafkaQuota method.
		ListReservedKafkaQuota []struct {
			// ProductID is the productID argument value.
			ProductID string
			// OrgID is the orgID argument value.
			OrgID string
		}
		// ReserveQuota holds details about calls to the ReserveQuota method.
		ReserveQuota []struct {
			// ProductID is the productID argument value.
			ProductID string
			// ClusterID is the clusterID argument value.
			ClusterID string
			// KafkaID is the kafkaID argument value.
			KafkaID string
			// Owner is the owner argument value.
			Owner string
			// Reserve is the reserve argument value.
			Reserve bool
			// Availability is the availability argument value.
			Availability string
		}
	}
	lockDeleteQuota            sync.RWMutex
	lockIsQuotaReserved        sync.RWMutex
	lockListReservedKafkaQuota sync.RWMutex
	lockReserveQuota           sync.RWMutex
}

// DeleteQuota calls DeleteQuotaFunc.
func (mock *QuotaServiceMock) DeleteQuota(id string) *apiErrors.ServiceError {
	if mock.DeleteQuotaFunc == nil {
		panic("QuotaServiceMock.DeleteQuotaFunc: method is nil but QuotaService.DeleteQuota was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockDeleteQuota.Lock()
	mock.calls.DeleteQuota = append(mock.calls.DeleteQuota, callInfo)
	mock.lockDeleteQuota.Unlock()
	return mock.DeleteQuotaFunc(id)
}

// DeleteQuotaCalls gets all the calls that were made to DeleteQuota.
// Check the length with:
//     len(mockedQuotaService.DeleteQuotaCalls())
func (mock *QuotaServiceMock) DeleteQuotaCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockDeleteQuota.RLock()
	calls = mock.calls.DeleteQuota
	mock.lockDeleteQuota.RUnlock()
	return calls
}

// IsQuotaReserved calls IsQuotaReservedFunc.
func (mock *QuotaServiceMock) IsQuotaReserved(productID string, orgID string) (bool, *apiErrors.ServiceError) {
	if mock.IsQuotaReservedFunc == nil {
		panic("QuotaServiceMock.IsQuotaReservedFunc: method is nil but QuotaService.IsQuotaReserved was just called")
	}
	callInfo := struct {
		ProductID string
		OrgID     string
	}{
		ProductID: productID,
		OrgID:     orgID,
	}
	mock.lockIsQuotaReserved.Lock()
	mock.calls.IsQuotaReserved = append(mock.calls.IsQuotaReserved, callInfo)
	mock.lockIsQuotaReserved.Unlock()
	return mock.IsQuotaReservedFunc(productID, orgID)
}

// IsQuotaReservedCalls gets all the calls that were made to IsQuotaReserved.
// Check the length with:
//     len(mockedQuotaService.IsQuotaReservedCalls())
func (mock *QuotaServiceMock) IsQuotaReservedCalls() []struct {
	ProductID string
	OrgID     string
} {
	var calls []struct {
		ProductID string
		OrgID     string
	}
	mock.lockIsQuotaReserved.RLock()
	calls = mock.calls.IsQuotaReserved
	mock.lockIsQuotaReserved.RUnlock()
	return calls
}

// ListReservedKafkaQuota calls ListReservedKafkaQuotaFunc.
func (mock *QuotaServiceMock) ListReservedKafkaQuota(productID string, orgID string) ([]string, *apiErrors.ServiceError) {
	if mock.ListReservedKafkaQuotaFunc == nil {
		panic("QuotaServiceMock.ListReservedKafkaQuotaFunc: method is nil but QuotaService.ListReservedKafkaQuota was just called")
	}
	callInfo := struct {
		ProductID string
		OrgID     string
	}{
		ProductID: productID,
		OrgID:     orgID,
	}
	mock.lockListReservedKafkaQuota.Lock()
	mock.calls.ListReservedKafkaQuota = append(mock.calls.ListReservedKafkaQuota, callInfo)
	mock.lockListReservedKafkaQuota.Unlock()
	return mock.ListReservedKafkaQuotaFunc(productID, orgID)
}

// ListReservedKafkaQuotaCalls gets all the calls that were made to ListReservedKafkaQuota.
// Check the length with:
//     len(mockedQuotaService.ListReservedKafkaQuotaCalls())
func (mock *QuotaServiceMock) ListReservedKafkaQuotaCalls() []struct {
	ProductID string
	OrgID     string
} {
	var calls []struct {
		ProductID string
		OrgID     string
	}
	mock.lockListReservedKafkaQuota.RLock()
	calls = mock.calls.ListReservedKafkaQuota
	mock.lockListReservedKafkaQuota.RUnlock()
	return calls
}

// ReserveQuota calls ReserveQuotaFunc.
func (mock *QuotaServiceMock) ReserveQuota(productID string, clusterID string, kafkaID string, owner string, reserve bool, availability string) (bool, string, *apiErrors.ServiceError) {
	if mock.ReserveQuotaFunc == nil {
		panic("QuotaServiceMock.ReserveQuotaFunc: method is nil but QuotaService.ReserveQuota was just called")
	}
	callInfo := struct {
		ProductID    string
		ClusterID    string
		KafkaID      string
		Owner        string
		Reserve      bool
		Availability string
	}{
		ProductID:    productID,
		ClusterID:    clusterID,
		KafkaID:      kafkaID,
		Owner:        owner,
		Reserve:      reserve,
		Availability: availability,
	}
	mock.lockReserveQuota.Lock()
	mock.calls.ReserveQuota = append(mock.calls.ReserveQuota, callInfo)
	mock.lockReserveQuota.Unlock()
	return mock.ReserveQuotaFunc(productID, clusterID, kafkaID, owner, reserve, availability)
}

// ReserveQuotaCalls gets all the calls that were made to ReserveQuota.
// Check the length with:
//     len(mockedQuotaService.ReserveQuotaCalls())
func (mock *QuotaServiceMock) ReserveQuotaCalls() []struct {
	ProductID    string
	ClusterID    string
	KafkaID      string
	Owner        string
	Reserve      bool
	Availability string
} {
	var calls []struct {
		ProductID    string
		ClusterID    string
		KafkaID      string
		Owner        string
		Reserve      bool
		Availability string
	}
	mock.lockReserveQuota.RLock()
	calls = mock.calls.ReserveQuota
	mock.lockReserveQuota.RUnlock()
	return calls
}
