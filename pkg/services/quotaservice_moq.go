// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	apiErrors "github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/errors"
	"sync"
)

// Ensure, that QuotaServiceMock does implement QuotaService.
// If this is not the case, regenerate this file with moq.
var _ QuotaService = &QuotaServiceMock{}

// QuotaServiceMock is a mock implementation of QuotaService.
//
// 	func TestSomethingThatUsesQuotaService(t *testing.T) {
//
// 		// make and configure a mocked QuotaService
// 		mockedQuotaService := &QuotaServiceMock{
// 			DeleteQuotaFunc: func(id string) *apiErrors.ServiceError {
// 				panic("mock out the DeleteQuota method")
// 			},
// 			IsQuotaAvailableFunc: func(productID string, orgID string) (bool, *apiErrors.ServiceError) {
// 				panic("mock out the IsQuotaAvailable method")
// 			},
// 			ListClustersWithValidQuotaFunc: func(productID string, orgID string) ([]string, *apiErrors.ServiceError) {
// 				panic("mock out the ListClustersWithValidQuota method")
// 			},
// 			ReserveQuotaFunc: func(productID string, clusterID string, kafkaID string, owner string, reserve bool, availability string) (bool, string, *apiErrors.ServiceError) {
// 				panic("mock out the ReserveQuota method")
// 			},
// 		}
//
// 		// use mockedQuotaService in code that requires QuotaService
// 		// and then make assertions.
//
// 	}
type QuotaServiceMock struct {
	// DeleteQuotaFunc mocks the DeleteQuota method.
	DeleteQuotaFunc func(id string) *apiErrors.ServiceError

	// IsQuotaAvailableFunc mocks the IsQuotaAvailable method.
	IsQuotaAvailableFunc func(productID string, orgID string) (bool, *apiErrors.ServiceError)

	// ListClustersWithValidQuotaFunc mocks the ListClustersWithValidQuota method.
	ListClustersWithValidQuotaFunc func(productID string, orgID string) ([]string, *apiErrors.ServiceError)

	// ReserveQuotaFunc mocks the ReserveQuota method.
	ReserveQuotaFunc func(productID string, clusterID string, kafkaID string, owner string, reserve bool, availability string) (bool, string, *apiErrors.ServiceError)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteQuota holds details about calls to the DeleteQuota method.
		DeleteQuota []struct {
			// ID is the id argument value.
			ID string
		}
		// IsQuotaAvailable holds details about calls to the IsQuotaAvailable method.
		IsQuotaAvailable []struct {
			// ProductID is the productID argument value.
			ProductID string
			// OrgID is the orgID argument value.
			OrgID string
		}
		// ListClustersWithValidQuota holds details about calls to the ListClustersWithValidQuota method.
		ListClustersWithValidQuota []struct {
			// ProductID is the productID argument value.
			ProductID string
			// OrgID is the orgID argument value.
			OrgID string
		}
		// ReserveQuota holds details about calls to the ReserveQuota method.
		ReserveQuota []struct {
			// ProductID is the productID argument value.
			ProductID string
			// ClusterID is the clusterID argument value.
			ClusterID string
			// KafkaID is the kafkaID argument value.
			KafkaID string
			// Owner is the owner argument value.
			Owner string
			// Reserve is the reserve argument value.
			Reserve bool
			// Availability is the availability argument value.
			Availability string
		}
	}
	lockDeleteQuota                sync.RWMutex
	lockIsQuotaAvailable           sync.RWMutex
	lockListClustersWithValidQuota sync.RWMutex
	lockReserveQuota               sync.RWMutex
}

// DeleteQuota calls DeleteQuotaFunc.
func (mock *QuotaServiceMock) DeleteQuota(id string) *apiErrors.ServiceError {
	if mock.DeleteQuotaFunc == nil {
		panic("QuotaServiceMock.DeleteQuotaFunc: method is nil but QuotaService.DeleteQuota was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockDeleteQuota.Lock()
	mock.calls.DeleteQuota = append(mock.calls.DeleteQuota, callInfo)
	mock.lockDeleteQuota.Unlock()
	return mock.DeleteQuotaFunc(id)
}

// DeleteQuotaCalls gets all the calls that were made to DeleteQuota.
// Check the length with:
//     len(mockedQuotaService.DeleteQuotaCalls())
func (mock *QuotaServiceMock) DeleteQuotaCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockDeleteQuota.RLock()
	calls = mock.calls.DeleteQuota
	mock.lockDeleteQuota.RUnlock()
	return calls
}

// IsQuotaAvailable calls IsQuotaAvailableFunc.
func (mock *QuotaServiceMock) IsQuotaAvailable(productID string, orgID string) (bool, *apiErrors.ServiceError) {
	if mock.IsQuotaAvailableFunc == nil {
		panic("QuotaServiceMock.IsQuotaAvailableFunc: method is nil but QuotaService.IsQuotaAvailable was just called")
	}
	callInfo := struct {
		ProductID string
		OrgID     string
	}{
		ProductID: productID,
		OrgID:     orgID,
	}
	mock.lockIsQuotaAvailable.Lock()
	mock.calls.IsQuotaAvailable = append(mock.calls.IsQuotaAvailable, callInfo)
	mock.lockIsQuotaAvailable.Unlock()
	return mock.IsQuotaAvailableFunc(productID, orgID)
}

// IsQuotaAvailableCalls gets all the calls that were made to IsQuotaAvailable.
// Check the length with:
//     len(mockedQuotaService.IsQuotaAvailableCalls())
func (mock *QuotaServiceMock) IsQuotaAvailableCalls() []struct {
	ProductID string
	OrgID     string
} {
	var calls []struct {
		ProductID string
		OrgID     string
	}
	mock.lockIsQuotaAvailable.RLock()
	calls = mock.calls.IsQuotaAvailable
	mock.lockIsQuotaAvailable.RUnlock()
	return calls
}

// ListClustersWithValidQuota calls ListClustersWithValidQuotaFunc.
func (mock *QuotaServiceMock) ListClustersWithValidQuota(productID string, orgID string) ([]string, *apiErrors.ServiceError) {
	if mock.ListClustersWithValidQuotaFunc == nil {
		panic("QuotaServiceMock.ListClustersWithValidQuotaFunc: method is nil but QuotaService.ListClustersWithValidQuota was just called")
	}
	callInfo := struct {
		ProductID string
		OrgID     string
	}{
		ProductID: productID,
		OrgID:     orgID,
	}
	mock.lockListClustersWithValidQuota.Lock()
	mock.calls.ListClustersWithValidQuota = append(mock.calls.ListClustersWithValidQuota, callInfo)
	mock.lockListClustersWithValidQuota.Unlock()
	return mock.ListClustersWithValidQuotaFunc(productID, orgID)
}

// ListClustersWithValidQuotaCalls gets all the calls that were made to ListClustersWithValidQuota.
// Check the length with:
//     len(mockedQuotaService.ListClustersWithValidQuotaCalls())
func (mock *QuotaServiceMock) ListClustersWithValidQuotaCalls() []struct {
	ProductID string
	OrgID     string
} {
	var calls []struct {
		ProductID string
		OrgID     string
	}
	mock.lockListClustersWithValidQuota.RLock()
	calls = mock.calls.ListClustersWithValidQuota
	mock.lockListClustersWithValidQuota.RUnlock()
	return calls
}

// ReserveQuota calls ReserveQuotaFunc.
func (mock *QuotaServiceMock) ReserveQuota(productID string, clusterID string, kafkaID string, owner string, reserve bool, availability string) (bool, string, *apiErrors.ServiceError) {
	if mock.ReserveQuotaFunc == nil {
		panic("QuotaServiceMock.ReserveQuotaFunc: method is nil but QuotaService.ReserveQuota was just called")
	}
	callInfo := struct {
		ProductID    string
		ClusterID    string
		KafkaID      string
		Owner        string
		Reserve      bool
		Availability string
	}{
		ProductID:    productID,
		ClusterID:    clusterID,
		KafkaID:      kafkaID,
		Owner:        owner,
		Reserve:      reserve,
		Availability: availability,
	}
	mock.lockReserveQuota.Lock()
	mock.calls.ReserveQuota = append(mock.calls.ReserveQuota, callInfo)
	mock.lockReserveQuota.Unlock()
	return mock.ReserveQuotaFunc(productID, clusterID, kafkaID, owner, reserve, availability)
}

// ReserveQuotaCalls gets all the calls that were made to ReserveQuota.
// Check the length with:
//     len(mockedQuotaService.ReserveQuotaCalls())
func (mock *QuotaServiceMock) ReserveQuotaCalls() []struct {
	ProductID    string
	ClusterID    string
	KafkaID      string
	Owner        string
	Reserve      bool
	Availability string
} {
	var calls []struct {
		ProductID    string
		ClusterID    string
		KafkaID      string
		Owner        string
		Reserve      bool
		Availability string
	}
	mock.lockReserveQuota.RLock()
	calls = mock.calls.ReserveQuota
	mock.lockReserveQuota.RUnlock()
	return calls
}
