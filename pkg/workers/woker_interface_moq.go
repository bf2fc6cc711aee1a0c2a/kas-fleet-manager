// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package workers

import (
	"sync"
)

// Ensure, that WorkerMock does implement Worker.
// If this is not the case, regenerate this file with moq.
var _ Worker = &WorkerMock{}

// WorkerMock is a mock implementation of Worker.
//
// 	func TestSomethingThatUsesWorker(t *testing.T) {
//
// 		// make and configure a mocked Worker
// 		mockedWorker := &WorkerMock{
// 			GetIDFunc: func() string {
// 				panic("mock out the GetID method")
// 			},
// 			GetStopChanFunc: func() *chan struct{} {
// 				panic("mock out the GetStopChan method")
// 			},
// 			GetSyncGroupFunc: func() *sync.WaitGroup {
// 				panic("mock out the GetSyncGroup method")
// 			},
// 			GetWorkerTypeFunc: func() string {
// 				panic("mock out the GetWorkerType method")
// 			},
// 			IsRunningFunc: func() bool {
// 				panic("mock out the IsRunning method")
// 			},
// 			ReconcileFunc: func() []error {
// 				panic("mock out the Reconcile method")
// 			},
// 			SetIsRunningFunc: func(val bool)  {
// 				panic("mock out the SetIsRunning method")
// 			},
// 			StartFunc: func()  {
// 				panic("mock out the Start method")
// 			},
// 			StopFunc: func()  {
// 				panic("mock out the Stop method")
// 			},
// 		}
//
// 		// use mockedWorker in code that requires Worker
// 		// and then make assertions.
//
// 	}
type WorkerMock struct {
	// GetIDFunc mocks the GetID method.
	GetIDFunc func() string

	// GetStopChanFunc mocks the GetStopChan method.
	GetStopChanFunc func() *chan struct{}

	// GetSyncGroupFunc mocks the GetSyncGroup method.
	GetSyncGroupFunc func() *sync.WaitGroup

	// GetWorkerTypeFunc mocks the GetWorkerType method.
	GetWorkerTypeFunc func() string

	// IsRunningFunc mocks the IsRunning method.
	IsRunningFunc func() bool

	// ReconcileFunc mocks the Reconcile method.
	ReconcileFunc func() []error

	// SetIsRunningFunc mocks the SetIsRunning method.
	SetIsRunningFunc func(val bool)

	// StartFunc mocks the Start method.
	StartFunc func()

	// StopFunc mocks the Stop method.
	StopFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// GetID holds details about calls to the GetID method.
		GetID []struct {
		}
		// GetStopChan holds details about calls to the GetStopChan method.
		GetStopChan []struct {
		}
		// GetSyncGroup holds details about calls to the GetSyncGroup method.
		GetSyncGroup []struct {
		}
		// GetWorkerType holds details about calls to the GetWorkerType method.
		GetWorkerType []struct {
		}
		// IsRunning holds details about calls to the IsRunning method.
		IsRunning []struct {
		}
		// Reconcile holds details about calls to the Reconcile method.
		Reconcile []struct {
		}
		// SetIsRunning holds details about calls to the SetIsRunning method.
		SetIsRunning []struct {
			// Val is the val argument value.
			Val bool
		}
		// Start holds details about calls to the Start method.
		Start []struct {
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
		}
	}
	lockGetID         sync.RWMutex
	lockGetStopChan   sync.RWMutex
	lockGetSyncGroup  sync.RWMutex
	lockGetWorkerType sync.RWMutex
	lockIsRunning     sync.RWMutex
	lockReconcile     sync.RWMutex
	lockSetIsRunning  sync.RWMutex
	lockStart         sync.RWMutex
	lockStop          sync.RWMutex
}

// GetID calls GetIDFunc.
func (mock *WorkerMock) GetID() string {
	if mock.GetIDFunc == nil {
		panic("WorkerMock.GetIDFunc: method is nil but Worker.GetID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetID.Lock()
	mock.calls.GetID = append(mock.calls.GetID, callInfo)
	mock.lockGetID.Unlock()
	return mock.GetIDFunc()
}

// GetIDCalls gets all the calls that were made to GetID.
// Check the length with:
//     len(mockedWorker.GetIDCalls())
func (mock *WorkerMock) GetIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetID.RLock()
	calls = mock.calls.GetID
	mock.lockGetID.RUnlock()
	return calls
}

// GetStopChan calls GetStopChanFunc.
func (mock *WorkerMock) GetStopChan() *chan struct{} {
	if mock.GetStopChanFunc == nil {
		panic("WorkerMock.GetStopChanFunc: method is nil but Worker.GetStopChan was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetStopChan.Lock()
	mock.calls.GetStopChan = append(mock.calls.GetStopChan, callInfo)
	mock.lockGetStopChan.Unlock()
	return mock.GetStopChanFunc()
}

// GetStopChanCalls gets all the calls that were made to GetStopChan.
// Check the length with:
//     len(mockedWorker.GetStopChanCalls())
func (mock *WorkerMock) GetStopChanCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetStopChan.RLock()
	calls = mock.calls.GetStopChan
	mock.lockGetStopChan.RUnlock()
	return calls
}

// GetSyncGroup calls GetSyncGroupFunc.
func (mock *WorkerMock) GetSyncGroup() *sync.WaitGroup {
	if mock.GetSyncGroupFunc == nil {
		panic("WorkerMock.GetSyncGroupFunc: method is nil but Worker.GetSyncGroup was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSyncGroup.Lock()
	mock.calls.GetSyncGroup = append(mock.calls.GetSyncGroup, callInfo)
	mock.lockGetSyncGroup.Unlock()
	return mock.GetSyncGroupFunc()
}

// GetSyncGroupCalls gets all the calls that were made to GetSyncGroup.
// Check the length with:
//     len(mockedWorker.GetSyncGroupCalls())
func (mock *WorkerMock) GetSyncGroupCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSyncGroup.RLock()
	calls = mock.calls.GetSyncGroup
	mock.lockGetSyncGroup.RUnlock()
	return calls
}

// GetWorkerType calls GetWorkerTypeFunc.
func (mock *WorkerMock) GetWorkerType() string {
	if mock.GetWorkerTypeFunc == nil {
		panic("WorkerMock.GetWorkerTypeFunc: method is nil but Worker.GetWorkerType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetWorkerType.Lock()
	mock.calls.GetWorkerType = append(mock.calls.GetWorkerType, callInfo)
	mock.lockGetWorkerType.Unlock()
	return mock.GetWorkerTypeFunc()
}

// GetWorkerTypeCalls gets all the calls that were made to GetWorkerType.
// Check the length with:
//     len(mockedWorker.GetWorkerTypeCalls())
func (mock *WorkerMock) GetWorkerTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetWorkerType.RLock()
	calls = mock.calls.GetWorkerType
	mock.lockGetWorkerType.RUnlock()
	return calls
}

// IsRunning calls IsRunningFunc.
func (mock *WorkerMock) IsRunning() bool {
	if mock.IsRunningFunc == nil {
		panic("WorkerMock.IsRunningFunc: method is nil but Worker.IsRunning was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsRunning.Lock()
	mock.calls.IsRunning = append(mock.calls.IsRunning, callInfo)
	mock.lockIsRunning.Unlock()
	return mock.IsRunningFunc()
}

// IsRunningCalls gets all the calls that were made to IsRunning.
// Check the length with:
//     len(mockedWorker.IsRunningCalls())
func (mock *WorkerMock) IsRunningCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsRunning.RLock()
	calls = mock.calls.IsRunning
	mock.lockIsRunning.RUnlock()
	return calls
}

// Reconcile calls ReconcileFunc.
func (mock *WorkerMock) Reconcile() []error {
	if mock.ReconcileFunc == nil {
		panic("WorkerMock.ReconcileFunc: method is nil but Worker.Reconcile was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReconcile.Lock()
	mock.calls.Reconcile = append(mock.calls.Reconcile, callInfo)
	mock.lockReconcile.Unlock()
	return mock.ReconcileFunc()
}

// ReconcileCalls gets all the calls that were made to Reconcile.
// Check the length with:
//     len(mockedWorker.ReconcileCalls())
func (mock *WorkerMock) ReconcileCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReconcile.RLock()
	calls = mock.calls.Reconcile
	mock.lockReconcile.RUnlock()
	return calls
}

// SetIsRunning calls SetIsRunningFunc.
func (mock *WorkerMock) SetIsRunning(val bool) {
	if mock.SetIsRunningFunc == nil {
		panic("WorkerMock.SetIsRunningFunc: method is nil but Worker.SetIsRunning was just called")
	}
	callInfo := struct {
		Val bool
	}{
		Val: val,
	}
	mock.lockSetIsRunning.Lock()
	mock.calls.SetIsRunning = append(mock.calls.SetIsRunning, callInfo)
	mock.lockSetIsRunning.Unlock()
	mock.SetIsRunningFunc(val)
}

// SetIsRunningCalls gets all the calls that were made to SetIsRunning.
// Check the length with:
//     len(mockedWorker.SetIsRunningCalls())
func (mock *WorkerMock) SetIsRunningCalls() []struct {
	Val bool
} {
	var calls []struct {
		Val bool
	}
	mock.lockSetIsRunning.RLock()
	calls = mock.calls.SetIsRunning
	mock.lockSetIsRunning.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *WorkerMock) Start() {
	if mock.StartFunc == nil {
		panic("WorkerMock.StartFunc: method is nil but Worker.Start was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc()
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//     len(mockedWorker.StartCalls())
func (mock *WorkerMock) StartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *WorkerMock) Stop() {
	if mock.StopFunc == nil {
		panic("WorkerMock.StopFunc: method is nil but Worker.Stop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	mock.StopFunc()
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//     len(mockedWorker.StopCalls())
func (mock *WorkerMock) StopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}
