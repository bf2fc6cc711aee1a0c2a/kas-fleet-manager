// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"context"
	"github.com/aws/aws-sdk-go/service/route53"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/constants"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/api/dbapi"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/kafkas/types"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/api"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/api/managedkafkas.managedkafka.bf2.org/v1"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/errors"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/services"
	"sync"
)

// Ensure, that KafkaServiceMock does implement KafkaService.
// If this is not the case, regenerate this file with moq.
var _ KafkaService = &KafkaServiceMock{}

// KafkaServiceMock is a mock implementation of KafkaService.
//
//     func TestSomethingThatUsesKafkaService(t *testing.T) {
//
//         // make and configure a mocked KafkaService
//         mockedKafkaService := &KafkaServiceMock{
//             AssignInstanceTypeFunc: func(kafkaRequest *dbapi.KafkaRequest) (types.KafkaInstanceType, *errors.ServiceError) {
// 	               panic("mock out the AssignInstanceType method")
//             },
//             ChangeKafkaCNAMErecordsFunc: func(kafkaRequest *dbapi.KafkaRequest, action KafkaRoutesAction) (*route53.ChangeResourceRecordSetsOutput, *errors.ServiceError) {
// 	               panic("mock out the ChangeKafkaCNAMErecords method")
//             },
//             CountByRegionAndInstanceTypeFunc: func() ([]KafkaRegionCount, error) {
// 	               panic("mock out the CountByRegionAndInstanceType method")
//             },
//             CountByStatusFunc: func(status []constants.KafkaStatus) ([]KafkaStatusCount, error) {
// 	               panic("mock out the CountByStatus method")
//             },
//             DeleteFunc: func(in1 *dbapi.KafkaRequest) *errors.ServiceError {
// 	               panic("mock out the Delete method")
//             },
//             DeprovisionExpiredKafkasFunc: func(kafkaAgeInHours int) *errors.ServiceError {
// 	               panic("mock out the DeprovisionExpiredKafkas method")
//             },
//             DeprovisionKafkaForUsersFunc: func(users []string) *errors.ServiceError {
// 	               panic("mock out the DeprovisionKafkaForUsers method")
//             },
//             GetFunc: func(ctx context.Context, id string) (*dbapi.KafkaRequest, *errors.ServiceError) {
// 	               panic("mock out the Get method")
//             },
//             GetByIdFunc: func(id string) (*dbapi.KafkaRequest, *errors.ServiceError) {
// 	               panic("mock out the GetById method")
//             },
//             GetCNAMERecordStatusFunc: func(kafkaRequest *dbapi.KafkaRequest) (*CNameRecordStatus, error) {
// 	               panic("mock out the GetCNAMERecordStatus method")
//             },
//             GetManagedKafkaByClusterIDFunc: func(clusterID string) ([]v1.ManagedKafka, *errors.ServiceError) {
// 	               panic("mock out the GetManagedKafkaByClusterID method")
//             },
//             HasAvailableCapacityInRegionFunc: func(kafkaRequest *dbapi.KafkaRequest) (bool, *errors.ServiceError) {
// 	               panic("mock out the HasAvailableCapacityInRegion method")
//             },
//             ListFunc: func(ctx context.Context, listArgs *services.ListArguments) (dbapi.KafkaList, *api.PagingMeta, *errors.ServiceError) {
// 	               panic("mock out the List method")
//             },
//             ListByStatusFunc: func(status ...constants.KafkaStatus) ([]*dbapi.KafkaRequest, *errors.ServiceError) {
// 	               panic("mock out the ListByStatus method")
//             },
//             ListComponentVersionsFunc: func() ([]KafkaComponentVersions, error) {
// 	               panic("mock out the ListComponentVersions method")
//             },
//             ListKafkasWithRoutesNotCreatedFunc: func() ([]*dbapi.KafkaRequest, *errors.ServiceError) {
// 	               panic("mock out the ListKafkasWithRoutesNotCreated method")
//             },
//             PrepareKafkaRequestFunc: func(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
// 	               panic("mock out the PrepareKafkaRequest method")
//             },
//             RegisterKafkaDeprovisionJobFunc: func(ctx context.Context, id string) *errors.ServiceError {
// 	               panic("mock out the RegisterKafkaDeprovisionJob method")
//             },
//             RegisterKafkaJobFunc: func(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
// 	               panic("mock out the RegisterKafkaJob method")
//             },
//             UpdateFunc: func(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
// 	               panic("mock out the Update method")
//             },
//             UpdateStatusFunc: func(id string, status constants.KafkaStatus) (bool, *errors.ServiceError) {
// 	               panic("mock out the UpdateStatus method")
//             },
//             UpdatesFunc: func(kafkaRequest *dbapi.KafkaRequest, values map[string]interface{}) *errors.ServiceError {
// 	               panic("mock out the Updates method")
//             },
//             VerifyAndUpdateKafkaAdminFunc: func(ctx context.Context, kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
// 	               panic("mock out the VerifyAndUpdateKafkaAdmin method")
//             },
//         }
//
//         // use mockedKafkaService in code that requires KafkaService
//         // and then make assertions.
//
//     }
type KafkaServiceMock struct {
	// AssignInstanceTypeFunc mocks the AssignInstanceType method.
	AssignInstanceTypeFunc func(kafkaRequest *dbapi.KafkaRequest) (types.KafkaInstanceType, *errors.ServiceError)

	// ChangeKafkaCNAMErecordsFunc mocks the ChangeKafkaCNAMErecords method.
	ChangeKafkaCNAMErecordsFunc func(kafkaRequest *dbapi.KafkaRequest, action KafkaRoutesAction) (*route53.ChangeResourceRecordSetsOutput, *errors.ServiceError)

	// CountByRegionAndInstanceTypeFunc mocks the CountByRegionAndInstanceType method.
	CountByRegionAndInstanceTypeFunc func() ([]KafkaRegionCount, error)

	// CountByStatusFunc mocks the CountByStatus method.
	CountByStatusFunc func(status []constants.KafkaStatus) ([]KafkaStatusCount, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(in1 *dbapi.KafkaRequest) *errors.ServiceError

	// DeprovisionExpiredKafkasFunc mocks the DeprovisionExpiredKafkas method.
	DeprovisionExpiredKafkasFunc func(kafkaAgeInHours int) *errors.ServiceError

	// DeprovisionKafkaForUsersFunc mocks the DeprovisionKafkaForUsers method.
	DeprovisionKafkaForUsersFunc func(users []string) *errors.ServiceError

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id string) (*dbapi.KafkaRequest, *errors.ServiceError)

	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(id string) (*dbapi.KafkaRequest, *errors.ServiceError)

	// GetCNAMERecordStatusFunc mocks the GetCNAMERecordStatus method.
	GetCNAMERecordStatusFunc func(kafkaRequest *dbapi.KafkaRequest) (*CNameRecordStatus, error)

	// GetManagedKafkaByClusterIDFunc mocks the GetManagedKafkaByClusterID method.
	GetManagedKafkaByClusterIDFunc func(clusterID string) ([]v1.ManagedKafka, *errors.ServiceError)

	// HasAvailableCapacityInRegionFunc mocks the HasAvailableCapacityInRegion method.
	HasAvailableCapacityInRegionFunc func(kafkaRequest *dbapi.KafkaRequest) (bool, *errors.ServiceError)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, listArgs *services.ListArguments) (dbapi.KafkaList, *api.PagingMeta, *errors.ServiceError)

	// ListByStatusFunc mocks the ListByStatus method.
	ListByStatusFunc func(status ...constants.KafkaStatus) ([]*dbapi.KafkaRequest, *errors.ServiceError)

	// ListComponentVersionsFunc mocks the ListComponentVersions method.
	ListComponentVersionsFunc func() ([]KafkaComponentVersions, error)

	// ListKafkasWithRoutesNotCreatedFunc mocks the ListKafkasWithRoutesNotCreated method.
	ListKafkasWithRoutesNotCreatedFunc func() ([]*dbapi.KafkaRequest, *errors.ServiceError)

	// PrepareKafkaRequestFunc mocks the PrepareKafkaRequest method.
	PrepareKafkaRequestFunc func(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError

	// RegisterKafkaDeprovisionJobFunc mocks the RegisterKafkaDeprovisionJob method.
	RegisterKafkaDeprovisionJobFunc func(ctx context.Context, id string) *errors.ServiceError

	// RegisterKafkaJobFunc mocks the RegisterKafkaJob method.
	RegisterKafkaJobFunc func(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError

	// UpdateFunc mocks the Update method.
	UpdateFunc func(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(id string, status constants.KafkaStatus) (bool, *errors.ServiceError)

	// UpdatesFunc mocks the Updates method.
	UpdatesFunc func(kafkaRequest *dbapi.KafkaRequest, values map[string]interface{}) *errors.ServiceError

	// VerifyAndUpdateKafkaAdminFunc mocks the VerifyAndUpdateKafkaAdmin method.
	VerifyAndUpdateKafkaAdminFunc func(ctx context.Context, kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError

	// calls tracks calls to the methods.
	calls struct {
		// AssignInstanceType holds details about calls to the AssignInstanceType method.
		AssignInstanceType []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// ChangeKafkaCNAMErecords holds details about calls to the ChangeKafkaCNAMErecords method.
		ChangeKafkaCNAMErecords []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
			// Action is the action argument value.
			Action KafkaRoutesAction
		}
		// CountByRegionAndInstanceType holds details about calls to the CountByRegionAndInstanceType method.
		CountByRegionAndInstanceType []struct {
		}
		// CountByStatus holds details about calls to the CountByStatus method.
		CountByStatus []struct {
			// Status is the status argument value.
			Status []constants.KafkaStatus
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// In1 is the in1 argument value.
			In1 *dbapi.KafkaRequest
		}
		// DeprovisionExpiredKafkas holds details about calls to the DeprovisionExpiredKafkas method.
		DeprovisionExpiredKafkas []struct {
			// KafkaAgeInHours is the kafkaAgeInHours argument value.
			KafkaAgeInHours int
		}
		// DeprovisionKafkaForUsers holds details about calls to the DeprovisionKafkaForUsers method.
		DeprovisionKafkaForUsers []struct {
			// Users is the users argument value.
			Users []string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// ID is the id argument value.
			ID string
		}
		// GetCNAMERecordStatus holds details about calls to the GetCNAMERecordStatus method.
		GetCNAMERecordStatus []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// GetManagedKafkaByClusterID holds details about calls to the GetManagedKafkaByClusterID method.
		GetManagedKafkaByClusterID []struct {
			// ClusterID is the clusterID argument value.
			ClusterID string
		}
		// HasAvailableCapacityInRegion holds details about calls to the HasAvailableCapacityInRegion method.
		HasAvailableCapacityInRegion []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ListArgs is the listArgs argument value.
			ListArgs *services.ListArguments
		}
		// ListByStatus holds details about calls to the ListByStatus method.
		ListByStatus []struct {
			// Status is the status argument value.
			Status []constants.KafkaStatus
		}
		// ListComponentVersions holds details about calls to the ListComponentVersions method.
		ListComponentVersions []struct {
		}
		// ListKafkasWithRoutesNotCreated holds details about calls to the ListKafkasWithRoutesNotCreated method.
		ListKafkasWithRoutesNotCreated []struct {
		}
		// PrepareKafkaRequest holds details about calls to the PrepareKafkaRequest method.
		PrepareKafkaRequest []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// RegisterKafkaDeprovisionJob holds details about calls to the RegisterKafkaDeprovisionJob method.
		RegisterKafkaDeprovisionJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// RegisterKafkaJob holds details about calls to the RegisterKafkaJob method.
		RegisterKafkaJob []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// ID is the id argument value.
			ID string
			// Status is the status argument value.
			Status constants.KafkaStatus
		}
		// Updates holds details about calls to the Updates method.
		Updates []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
			// Values is the values argument value.
			Values map[string]interface{}
		}
		// VerifyAndUpdateKafkaAdmin holds details about calls to the VerifyAndUpdateKafkaAdmin method.
		VerifyAndUpdateKafkaAdmin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
	}
	lockAssignInstanceType             sync.RWMutex
	lockChangeKafkaCNAMErecords        sync.RWMutex
	lockCountByRegionAndInstanceType   sync.RWMutex
	lockCountByStatus                  sync.RWMutex
	lockDelete                         sync.RWMutex
	lockDeprovisionExpiredKafkas       sync.RWMutex
	lockDeprovisionKafkaForUsers       sync.RWMutex
	lockGet                            sync.RWMutex
	lockGetById                        sync.RWMutex
	lockGetCNAMERecordStatus           sync.RWMutex
	lockGetManagedKafkaByClusterID     sync.RWMutex
	lockHasAvailableCapacityInRegion   sync.RWMutex
	lockList                           sync.RWMutex
	lockListByStatus                   sync.RWMutex
	lockListComponentVersions          sync.RWMutex
	lockListKafkasWithRoutesNotCreated sync.RWMutex
	lockPrepareKafkaRequest            sync.RWMutex
	lockRegisterKafkaDeprovisionJob    sync.RWMutex
	lockRegisterKafkaJob               sync.RWMutex
	lockUpdate                         sync.RWMutex
	lockUpdateStatus                   sync.RWMutex
	lockUpdates                        sync.RWMutex
	lockVerifyAndUpdateKafkaAdmin      sync.RWMutex
}

// AssignInstanceType calls AssignInstanceTypeFunc.
func (mock *KafkaServiceMock) AssignInstanceType(kafkaRequest *dbapi.KafkaRequest) (types.KafkaInstanceType, *errors.ServiceError) {
	if mock.AssignInstanceTypeFunc == nil {
		panic("KafkaServiceMock.AssignInstanceTypeFunc: method is nil but KafkaService.AssignInstanceType was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockAssignInstanceType.Lock()
	mock.calls.AssignInstanceType = append(mock.calls.AssignInstanceType, callInfo)
	mock.lockAssignInstanceType.Unlock()
	return mock.AssignInstanceTypeFunc(kafkaRequest)
}

// AssignInstanceTypeCalls gets all the calls that were made to AssignInstanceType.
// Check the length with:
//     len(mockedKafkaService.AssignInstanceTypeCalls())
func (mock *KafkaServiceMock) AssignInstanceTypeCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockAssignInstanceType.RLock()
	calls = mock.calls.AssignInstanceType
	mock.lockAssignInstanceType.RUnlock()
	return calls
}

// ChangeKafkaCNAMErecords calls ChangeKafkaCNAMErecordsFunc.
func (mock *KafkaServiceMock) ChangeKafkaCNAMErecords(kafkaRequest *dbapi.KafkaRequest, action KafkaRoutesAction) (*route53.ChangeResourceRecordSetsOutput, *errors.ServiceError) {
	if mock.ChangeKafkaCNAMErecordsFunc == nil {
		panic("KafkaServiceMock.ChangeKafkaCNAMErecordsFunc: method is nil but KafkaService.ChangeKafkaCNAMErecords was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
		Action       KafkaRoutesAction
	}{
		KafkaRequest: kafkaRequest,
		Action:       action,
	}
	mock.lockChangeKafkaCNAMErecords.Lock()
	mock.calls.ChangeKafkaCNAMErecords = append(mock.calls.ChangeKafkaCNAMErecords, callInfo)
	mock.lockChangeKafkaCNAMErecords.Unlock()
	return mock.ChangeKafkaCNAMErecordsFunc(kafkaRequest, action)
}

// ChangeKafkaCNAMErecordsCalls gets all the calls that were made to ChangeKafkaCNAMErecords.
// Check the length with:
//     len(mockedKafkaService.ChangeKafkaCNAMErecordsCalls())
func (mock *KafkaServiceMock) ChangeKafkaCNAMErecordsCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
	Action       KafkaRoutesAction
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
		Action       KafkaRoutesAction
	}
	mock.lockChangeKafkaCNAMErecords.RLock()
	calls = mock.calls.ChangeKafkaCNAMErecords
	mock.lockChangeKafkaCNAMErecords.RUnlock()
	return calls
}

// CountByRegionAndInstanceType calls CountByRegionAndInstanceTypeFunc.
func (mock *KafkaServiceMock) CountByRegionAndInstanceType() ([]KafkaRegionCount, error) {
	if mock.CountByRegionAndInstanceTypeFunc == nil {
		panic("KafkaServiceMock.CountByRegionAndInstanceTypeFunc: method is nil but KafkaService.CountByRegionAndInstanceType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCountByRegionAndInstanceType.Lock()
	mock.calls.CountByRegionAndInstanceType = append(mock.calls.CountByRegionAndInstanceType, callInfo)
	mock.lockCountByRegionAndInstanceType.Unlock()
	return mock.CountByRegionAndInstanceTypeFunc()
}

// CountByRegionAndInstanceTypeCalls gets all the calls that were made to CountByRegionAndInstanceType.
// Check the length with:
//     len(mockedKafkaService.CountByRegionAndInstanceTypeCalls())
func (mock *KafkaServiceMock) CountByRegionAndInstanceTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCountByRegionAndInstanceType.RLock()
	calls = mock.calls.CountByRegionAndInstanceType
	mock.lockCountByRegionAndInstanceType.RUnlock()
	return calls
}

// CountByStatus calls CountByStatusFunc.
func (mock *KafkaServiceMock) CountByStatus(status []constants.KafkaStatus) ([]KafkaStatusCount, error) {
	if mock.CountByStatusFunc == nil {
		panic("KafkaServiceMock.CountByStatusFunc: method is nil but KafkaService.CountByStatus was just called")
	}
	callInfo := struct {
		Status []constants.KafkaStatus
	}{
		Status: status,
	}
	mock.lockCountByStatus.Lock()
	mock.calls.CountByStatus = append(mock.calls.CountByStatus, callInfo)
	mock.lockCountByStatus.Unlock()
	return mock.CountByStatusFunc(status)
}

// CountByStatusCalls gets all the calls that were made to CountByStatus.
// Check the length with:
//     len(mockedKafkaService.CountByStatusCalls())
func (mock *KafkaServiceMock) CountByStatusCalls() []struct {
	Status []constants.KafkaStatus
} {
	var calls []struct {
		Status []constants.KafkaStatus
	}
	mock.lockCountByStatus.RLock()
	calls = mock.calls.CountByStatus
	mock.lockCountByStatus.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KafkaServiceMock) Delete(in1 *dbapi.KafkaRequest) *errors.ServiceError {
	if mock.DeleteFunc == nil {
		panic("KafkaServiceMock.DeleteFunc: method is nil but KafkaService.Delete was just called")
	}
	callInfo := struct {
		In1 *dbapi.KafkaRequest
	}{
		In1: in1,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(in1)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedKafkaService.DeleteCalls())
func (mock *KafkaServiceMock) DeleteCalls() []struct {
	In1 *dbapi.KafkaRequest
} {
	var calls []struct {
		In1 *dbapi.KafkaRequest
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeprovisionExpiredKafkas calls DeprovisionExpiredKafkasFunc.
func (mock *KafkaServiceMock) DeprovisionExpiredKafkas(kafkaAgeInHours int) *errors.ServiceError {
	if mock.DeprovisionExpiredKafkasFunc == nil {
		panic("KafkaServiceMock.DeprovisionExpiredKafkasFunc: method is nil but KafkaService.DeprovisionExpiredKafkas was just called")
	}
	callInfo := struct {
		KafkaAgeInHours int
	}{
		KafkaAgeInHours: kafkaAgeInHours,
	}
	mock.lockDeprovisionExpiredKafkas.Lock()
	mock.calls.DeprovisionExpiredKafkas = append(mock.calls.DeprovisionExpiredKafkas, callInfo)
	mock.lockDeprovisionExpiredKafkas.Unlock()
	return mock.DeprovisionExpiredKafkasFunc(kafkaAgeInHours)
}

// DeprovisionExpiredKafkasCalls gets all the calls that were made to DeprovisionExpiredKafkas.
// Check the length with:
//     len(mockedKafkaService.DeprovisionExpiredKafkasCalls())
func (mock *KafkaServiceMock) DeprovisionExpiredKafkasCalls() []struct {
	KafkaAgeInHours int
} {
	var calls []struct {
		KafkaAgeInHours int
	}
	mock.lockDeprovisionExpiredKafkas.RLock()
	calls = mock.calls.DeprovisionExpiredKafkas
	mock.lockDeprovisionExpiredKafkas.RUnlock()
	return calls
}

// DeprovisionKafkaForUsers calls DeprovisionKafkaForUsersFunc.
func (mock *KafkaServiceMock) DeprovisionKafkaForUsers(users []string) *errors.ServiceError {
	if mock.DeprovisionKafkaForUsersFunc == nil {
		panic("KafkaServiceMock.DeprovisionKafkaForUsersFunc: method is nil but KafkaService.DeprovisionKafkaForUsers was just called")
	}
	callInfo := struct {
		Users []string
	}{
		Users: users,
	}
	mock.lockDeprovisionKafkaForUsers.Lock()
	mock.calls.DeprovisionKafkaForUsers = append(mock.calls.DeprovisionKafkaForUsers, callInfo)
	mock.lockDeprovisionKafkaForUsers.Unlock()
	return mock.DeprovisionKafkaForUsersFunc(users)
}

// DeprovisionKafkaForUsersCalls gets all the calls that were made to DeprovisionKafkaForUsers.
// Check the length with:
//     len(mockedKafkaService.DeprovisionKafkaForUsersCalls())
func (mock *KafkaServiceMock) DeprovisionKafkaForUsersCalls() []struct {
	Users []string
} {
	var calls []struct {
		Users []string
	}
	mock.lockDeprovisionKafkaForUsers.RLock()
	calls = mock.calls.DeprovisionKafkaForUsers
	mock.lockDeprovisionKafkaForUsers.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KafkaServiceMock) Get(ctx context.Context, id string) (*dbapi.KafkaRequest, *errors.ServiceError) {
	if mock.GetFunc == nil {
		panic("KafkaServiceMock.GetFunc: method is nil but KafkaService.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedKafkaService.GetCalls())
func (mock *KafkaServiceMock) GetCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetById calls GetByIdFunc.
func (mock *KafkaServiceMock) GetById(id string) (*dbapi.KafkaRequest, *errors.ServiceError) {
	if mock.GetByIdFunc == nil {
		panic("KafkaServiceMock.GetByIdFunc: method is nil but KafkaService.GetById was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(id)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//     len(mockedKafkaService.GetByIdCalls())
func (mock *KafkaServiceMock) GetByIdCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}

// GetCNAMERecordStatus calls GetCNAMERecordStatusFunc.
func (mock *KafkaServiceMock) GetCNAMERecordStatus(kafkaRequest *dbapi.KafkaRequest) (*CNameRecordStatus, error) {
	if mock.GetCNAMERecordStatusFunc == nil {
		panic("KafkaServiceMock.GetCNAMERecordStatusFunc: method is nil but KafkaService.GetCNAMERecordStatus was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockGetCNAMERecordStatus.Lock()
	mock.calls.GetCNAMERecordStatus = append(mock.calls.GetCNAMERecordStatus, callInfo)
	mock.lockGetCNAMERecordStatus.Unlock()
	return mock.GetCNAMERecordStatusFunc(kafkaRequest)
}

// GetCNAMERecordStatusCalls gets all the calls that were made to GetCNAMERecordStatus.
// Check the length with:
//     len(mockedKafkaService.GetCNAMERecordStatusCalls())
func (mock *KafkaServiceMock) GetCNAMERecordStatusCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockGetCNAMERecordStatus.RLock()
	calls = mock.calls.GetCNAMERecordStatus
	mock.lockGetCNAMERecordStatus.RUnlock()
	return calls
}

// GetManagedKafkaByClusterID calls GetManagedKafkaByClusterIDFunc.
func (mock *KafkaServiceMock) GetManagedKafkaByClusterID(clusterID string) ([]v1.ManagedKafka, *errors.ServiceError) {
	if mock.GetManagedKafkaByClusterIDFunc == nil {
		panic("KafkaServiceMock.GetManagedKafkaByClusterIDFunc: method is nil but KafkaService.GetManagedKafkaByClusterID was just called")
	}
	callInfo := struct {
		ClusterID string
	}{
		ClusterID: clusterID,
	}
	mock.lockGetManagedKafkaByClusterID.Lock()
	mock.calls.GetManagedKafkaByClusterID = append(mock.calls.GetManagedKafkaByClusterID, callInfo)
	mock.lockGetManagedKafkaByClusterID.Unlock()
	return mock.GetManagedKafkaByClusterIDFunc(clusterID)
}

// GetManagedKafkaByClusterIDCalls gets all the calls that were made to GetManagedKafkaByClusterID.
// Check the length with:
//     len(mockedKafkaService.GetManagedKafkaByClusterIDCalls())
func (mock *KafkaServiceMock) GetManagedKafkaByClusterIDCalls() []struct {
	ClusterID string
} {
	var calls []struct {
		ClusterID string
	}
	mock.lockGetManagedKafkaByClusterID.RLock()
	calls = mock.calls.GetManagedKafkaByClusterID
	mock.lockGetManagedKafkaByClusterID.RUnlock()
	return calls
}

// HasAvailableCapacityInRegion calls HasAvailableCapacityInRegionFunc.
func (mock *KafkaServiceMock) HasAvailableCapacityInRegion(kafkaRequest *dbapi.KafkaRequest) (bool, *errors.ServiceError) {
	if mock.HasAvailableCapacityInRegionFunc == nil {
		panic("KafkaServiceMock.HasAvailableCapacityInRegionFunc: method is nil but KafkaService.HasAvailableCapacityInRegion was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockHasAvailableCapacityInRegion.Lock()
	mock.calls.HasAvailableCapacityInRegion = append(mock.calls.HasAvailableCapacityInRegion, callInfo)
	mock.lockHasAvailableCapacityInRegion.Unlock()
	return mock.HasAvailableCapacityInRegionFunc(kafkaRequest)
}

// HasAvailableCapacityInRegionCalls gets all the calls that were made to HasAvailableCapacityInRegion.
// Check the length with:
//     len(mockedKafkaService.HasAvailableCapacityInRegionCalls())
func (mock *KafkaServiceMock) HasAvailableCapacityInRegionCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockHasAvailableCapacityInRegion.RLock()
	calls = mock.calls.HasAvailableCapacityInRegion
	mock.lockHasAvailableCapacityInRegion.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *KafkaServiceMock) List(ctx context.Context, listArgs *services.ListArguments) (dbapi.KafkaList, *api.PagingMeta, *errors.ServiceError) {
	if mock.ListFunc == nil {
		panic("KafkaServiceMock.ListFunc: method is nil but KafkaService.List was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ListArgs *services.ListArguments
	}{
		Ctx:      ctx,
		ListArgs: listArgs,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, listArgs)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedKafkaService.ListCalls())
func (mock *KafkaServiceMock) ListCalls() []struct {
	Ctx      context.Context
	ListArgs *services.ListArguments
} {
	var calls []struct {
		Ctx      context.Context
		ListArgs *services.ListArguments
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// ListByStatus calls ListByStatusFunc.
func (mock *KafkaServiceMock) ListByStatus(status ...constants.KafkaStatus) ([]*dbapi.KafkaRequest, *errors.ServiceError) {
	if mock.ListByStatusFunc == nil {
		panic("KafkaServiceMock.ListByStatusFunc: method is nil but KafkaService.ListByStatus was just called")
	}
	callInfo := struct {
		Status []constants.KafkaStatus
	}{
		Status: status,
	}
	mock.lockListByStatus.Lock()
	mock.calls.ListByStatus = append(mock.calls.ListByStatus, callInfo)
	mock.lockListByStatus.Unlock()
	return mock.ListByStatusFunc(status...)
}

// ListByStatusCalls gets all the calls that were made to ListByStatus.
// Check the length with:
//     len(mockedKafkaService.ListByStatusCalls())
func (mock *KafkaServiceMock) ListByStatusCalls() []struct {
	Status []constants.KafkaStatus
} {
	var calls []struct {
		Status []constants.KafkaStatus
	}
	mock.lockListByStatus.RLock()
	calls = mock.calls.ListByStatus
	mock.lockListByStatus.RUnlock()
	return calls
}

// ListComponentVersions calls ListComponentVersionsFunc.
func (mock *KafkaServiceMock) ListComponentVersions() ([]KafkaComponentVersions, error) {
	if mock.ListComponentVersionsFunc == nil {
		panic("KafkaServiceMock.ListComponentVersionsFunc: method is nil but KafkaService.ListComponentVersions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListComponentVersions.Lock()
	mock.calls.ListComponentVersions = append(mock.calls.ListComponentVersions, callInfo)
	mock.lockListComponentVersions.Unlock()
	return mock.ListComponentVersionsFunc()
}

// ListComponentVersionsCalls gets all the calls that were made to ListComponentVersions.
// Check the length with:
//     len(mockedKafkaService.ListComponentVersionsCalls())
func (mock *KafkaServiceMock) ListComponentVersionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListComponentVersions.RLock()
	calls = mock.calls.ListComponentVersions
	mock.lockListComponentVersions.RUnlock()
	return calls
}

// ListKafkasWithRoutesNotCreated calls ListKafkasWithRoutesNotCreatedFunc.
func (mock *KafkaServiceMock) ListKafkasWithRoutesNotCreated() ([]*dbapi.KafkaRequest, *errors.ServiceError) {
	if mock.ListKafkasWithRoutesNotCreatedFunc == nil {
		panic("KafkaServiceMock.ListKafkasWithRoutesNotCreatedFunc: method is nil but KafkaService.ListKafkasWithRoutesNotCreated was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListKafkasWithRoutesNotCreated.Lock()
	mock.calls.ListKafkasWithRoutesNotCreated = append(mock.calls.ListKafkasWithRoutesNotCreated, callInfo)
	mock.lockListKafkasWithRoutesNotCreated.Unlock()
	return mock.ListKafkasWithRoutesNotCreatedFunc()
}

// ListKafkasWithRoutesNotCreatedCalls gets all the calls that were made to ListKafkasWithRoutesNotCreated.
// Check the length with:
//     len(mockedKafkaService.ListKafkasWithRoutesNotCreatedCalls())
func (mock *KafkaServiceMock) ListKafkasWithRoutesNotCreatedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListKafkasWithRoutesNotCreated.RLock()
	calls = mock.calls.ListKafkasWithRoutesNotCreated
	mock.lockListKafkasWithRoutesNotCreated.RUnlock()
	return calls
}

// PrepareKafkaRequest calls PrepareKafkaRequestFunc.
func (mock *KafkaServiceMock) PrepareKafkaRequest(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
	if mock.PrepareKafkaRequestFunc == nil {
		panic("KafkaServiceMock.PrepareKafkaRequestFunc: method is nil but KafkaService.PrepareKafkaRequest was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockPrepareKafkaRequest.Lock()
	mock.calls.PrepareKafkaRequest = append(mock.calls.PrepareKafkaRequest, callInfo)
	mock.lockPrepareKafkaRequest.Unlock()
	return mock.PrepareKafkaRequestFunc(kafkaRequest)
}

// PrepareKafkaRequestCalls gets all the calls that were made to PrepareKafkaRequest.
// Check the length with:
//     len(mockedKafkaService.PrepareKafkaRequestCalls())
func (mock *KafkaServiceMock) PrepareKafkaRequestCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockPrepareKafkaRequest.RLock()
	calls = mock.calls.PrepareKafkaRequest
	mock.lockPrepareKafkaRequest.RUnlock()
	return calls
}

// RegisterKafkaDeprovisionJob calls RegisterKafkaDeprovisionJobFunc.
func (mock *KafkaServiceMock) RegisterKafkaDeprovisionJob(ctx context.Context, id string) *errors.ServiceError {
	if mock.RegisterKafkaDeprovisionJobFunc == nil {
		panic("KafkaServiceMock.RegisterKafkaDeprovisionJobFunc: method is nil but KafkaService.RegisterKafkaDeprovisionJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRegisterKafkaDeprovisionJob.Lock()
	mock.calls.RegisterKafkaDeprovisionJob = append(mock.calls.RegisterKafkaDeprovisionJob, callInfo)
	mock.lockRegisterKafkaDeprovisionJob.Unlock()
	return mock.RegisterKafkaDeprovisionJobFunc(ctx, id)
}

// RegisterKafkaDeprovisionJobCalls gets all the calls that were made to RegisterKafkaDeprovisionJob.
// Check the length with:
//     len(mockedKafkaService.RegisterKafkaDeprovisionJobCalls())
func (mock *KafkaServiceMock) RegisterKafkaDeprovisionJobCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockRegisterKafkaDeprovisionJob.RLock()
	calls = mock.calls.RegisterKafkaDeprovisionJob
	mock.lockRegisterKafkaDeprovisionJob.RUnlock()
	return calls
}

// RegisterKafkaJob calls RegisterKafkaJobFunc.
func (mock *KafkaServiceMock) RegisterKafkaJob(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
	if mock.RegisterKafkaJobFunc == nil {
		panic("KafkaServiceMock.RegisterKafkaJobFunc: method is nil but KafkaService.RegisterKafkaJob was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockRegisterKafkaJob.Lock()
	mock.calls.RegisterKafkaJob = append(mock.calls.RegisterKafkaJob, callInfo)
	mock.lockRegisterKafkaJob.Unlock()
	return mock.RegisterKafkaJobFunc(kafkaRequest)
}

// RegisterKafkaJobCalls gets all the calls that were made to RegisterKafkaJob.
// Check the length with:
//     len(mockedKafkaService.RegisterKafkaJobCalls())
func (mock *KafkaServiceMock) RegisterKafkaJobCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockRegisterKafkaJob.RLock()
	calls = mock.calls.RegisterKafkaJob
	mock.lockRegisterKafkaJob.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *KafkaServiceMock) Update(kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
	if mock.UpdateFunc == nil {
		panic("KafkaServiceMock.UpdateFunc: method is nil but KafkaService.Update was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(kafkaRequest)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedKafkaService.UpdateCalls())
func (mock *KafkaServiceMock) UpdateCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *KafkaServiceMock) UpdateStatus(id string, status constants.KafkaStatus) (bool, *errors.ServiceError) {
	if mock.UpdateStatusFunc == nil {
		panic("KafkaServiceMock.UpdateStatusFunc: method is nil but KafkaService.UpdateStatus was just called")
	}
	callInfo := struct {
		ID     string
		Status constants.KafkaStatus
	}{
		ID:     id,
		Status: status,
	}
	mock.lockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	mock.lockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(id, status)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//     len(mockedKafkaService.UpdateStatusCalls())
func (mock *KafkaServiceMock) UpdateStatusCalls() []struct {
	ID     string
	Status constants.KafkaStatus
} {
	var calls []struct {
		ID     string
		Status constants.KafkaStatus
	}
	mock.lockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	mock.lockUpdateStatus.RUnlock()
	return calls
}

// Updates calls UpdatesFunc.
func (mock *KafkaServiceMock) Updates(kafkaRequest *dbapi.KafkaRequest, values map[string]interface{}) *errors.ServiceError {
	if mock.UpdatesFunc == nil {
		panic("KafkaServiceMock.UpdatesFunc: method is nil but KafkaService.Updates was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
		Values       map[string]interface{}
	}{
		KafkaRequest: kafkaRequest,
		Values:       values,
	}
	mock.lockUpdates.Lock()
	mock.calls.Updates = append(mock.calls.Updates, callInfo)
	mock.lockUpdates.Unlock()
	return mock.UpdatesFunc(kafkaRequest, values)
}

// UpdatesCalls gets all the calls that were made to Updates.
// Check the length with:
//     len(mockedKafkaService.UpdatesCalls())
func (mock *KafkaServiceMock) UpdatesCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
	Values       map[string]interface{}
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
		Values       map[string]interface{}
	}
	mock.lockUpdates.RLock()
	calls = mock.calls.Updates
	mock.lockUpdates.RUnlock()
	return calls
}

// VerifyAndUpdateKafkaAdmin calls VerifyAndUpdateKafkaAdminFunc.
func (mock *KafkaServiceMock) VerifyAndUpdateKafkaAdmin(ctx context.Context, kafkaRequest *dbapi.KafkaRequest) *errors.ServiceError {
	if mock.VerifyAndUpdateKafkaAdminFunc == nil {
		panic("KafkaServiceMock.VerifyAndUpdateKafkaAdminFunc: method is nil but KafkaService.VerifyAndUpdateKafkaAdmin was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		KafkaRequest *dbapi.KafkaRequest
	}{
		Ctx:          ctx,
		KafkaRequest: kafkaRequest,
	}
	mock.lockVerifyAndUpdateKafkaAdmin.Lock()
	mock.calls.VerifyAndUpdateKafkaAdmin = append(mock.calls.VerifyAndUpdateKafkaAdmin, callInfo)
	mock.lockVerifyAndUpdateKafkaAdmin.Unlock()
	return mock.VerifyAndUpdateKafkaAdminFunc(ctx, kafkaRequest)
}

// VerifyAndUpdateKafkaAdminCalls gets all the calls that were made to VerifyAndUpdateKafkaAdmin.
// Check the length with:
//     len(mockedKafkaService.VerifyAndUpdateKafkaAdminCalls())
func (mock *KafkaServiceMock) VerifyAndUpdateKafkaAdminCalls() []struct {
	Ctx          context.Context
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		Ctx          context.Context
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockVerifyAndUpdateKafkaAdmin.RLock()
	calls = mock.calls.VerifyAndUpdateKafkaAdmin
	mock.lockVerifyAndUpdateKafkaAdmin.RUnlock()
	return calls
}
