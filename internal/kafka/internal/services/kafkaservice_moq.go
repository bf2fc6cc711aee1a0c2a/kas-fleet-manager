// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"context"
	"github.com/aws/aws-sdk-go/service/route53"
	constants2 "github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/constants"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/api/dbapi"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/kafkas/types"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/api"
	managedkafka "github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/api/managedkafkas.managedkafka.bf2.org/v1"
	serviceError "github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/errors"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/services"
	"sync"
)

// Ensure, that KafkaServiceMock does implement KafkaService.
// If this is not the case, regenerate this file with moq.
var _ KafkaService = &KafkaServiceMock{}

// KafkaServiceMock is a mock implementation of KafkaService.
//
// 	func TestSomethingThatUsesKafkaService(t *testing.T) {
//
// 		// make and configure a mocked KafkaService
// 		mockedKafkaService := &KafkaServiceMock{
// 			AssignBootstrapServerHostFunc: func(kafkaRequest *dbapi.KafkaRequest) error {
// 				panic("mock out the AssignBootstrapServerHost method")
// 			},
// 			AssignInstanceTypeFunc: func(owner string, organisationID string) (types.KafkaInstanceType, *serviceError.ServiceError) {
// 				panic("mock out the AssignInstanceType method")
// 			},
// 			ChangeKafkaCNAMErecordsFunc: func(kafkaRequest *dbapi.KafkaRequest, action KafkaRoutesAction) (*route53.ChangeResourceRecordSetsOutput, *serviceError.ServiceError) {
// 				panic("mock out the ChangeKafkaCNAMErecords method")
// 			},
// 			CountByStatusFunc: func(status []constants2.KafkaStatus) ([]KafkaStatusCount, error) {
// 				panic("mock out the CountByStatus method")
// 			},
// 			CountStreamingUnitByRegionAndInstanceTypeFunc: func() ([]KafkaStreamingUnitCountPerRegion, error) {
// 				panic("mock out the CountStreamingUnitByRegionAndInstanceType method")
// 			},
// 			DeleteFunc: func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
// 				panic("mock out the Delete method")
// 			},
// 			DeprovisionExpiredKafkasFunc: func() *serviceError.ServiceError {
// 				panic("mock out the DeprovisionExpiredKafkas method")
// 			},
// 			DeprovisionKafkaForUsersFunc: func(users []string) *serviceError.ServiceError {
// 				panic("mock out the DeprovisionKafkaForUsers method")
// 			},
// 			GenerateReservedManagedKafkasByClusterIDFunc: func(clusterID string) ([]managedkafka.ManagedKafka, *serviceError.ServiceError) {
// 				panic("mock out the GenerateReservedManagedKafkasByClusterID method")
// 			},
// 			GetFunc: func(ctx context.Context, id string) (*dbapi.KafkaRequest, *serviceError.ServiceError) {
// 				panic("mock out the Get method")
// 			},
// 			GetAvailableSizesInRegionFunc: func(criteria *FindClusterCriteria) ([]string, *serviceError.ServiceError) {
// 				panic("mock out the GetAvailableSizesInRegion method")
// 			},
// 			GetByIdFunc: func(id string) (*dbapi.KafkaRequest, *serviceError.ServiceError) {
// 				panic("mock out the GetById method")
// 			},
// 			GetCNAMERecordStatusFunc: func(kafkaRequest *dbapi.KafkaRequest) (*CNameRecordStatus, error) {
// 				panic("mock out the GetCNAMERecordStatus method")
// 			},
// 			GetManagedKafkaByClusterIDFunc: func(clusterID string) ([]managedkafka.ManagedKafka, *serviceError.ServiceError) {
// 				panic("mock out the GetManagedKafkaByClusterID method")
// 			},
// 			HasAvailableCapacityInRegionFunc: func(kafkaRequest *dbapi.KafkaRequest) (bool, *serviceError.ServiceError) {
// 				panic("mock out the HasAvailableCapacityInRegion method")
// 			},
// 			ListFunc: func(ctx context.Context, listArgs *services.ListArguments) (dbapi.KafkaList, *api.PagingMeta, *serviceError.ServiceError) {
// 				panic("mock out the List method")
// 			},
// 			ListByStatusFunc: func(status ...constants2.KafkaStatus) ([]*dbapi.KafkaRequest, *serviceError.ServiceError) {
// 				panic("mock out the ListByStatus method")
// 			},
// 			ListComponentVersionsFunc: func() ([]KafkaComponentVersions, error) {
// 				panic("mock out the ListComponentVersions method")
// 			},
// 			ListKafkasWithRoutesNotCreatedFunc: func() ([]*dbapi.KafkaRequest, *serviceError.ServiceError) {
// 				panic("mock out the ListKafkasWithRoutesNotCreated method")
// 			},
// 			PrepareKafkaRequestFunc: func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
// 				panic("mock out the PrepareKafkaRequest method")
// 			},
// 			RegisterKafkaDeprovisionJobFunc: func(ctx context.Context, id string) *serviceError.ServiceError {
// 				panic("mock out the RegisterKafkaDeprovisionJob method")
// 			},
// 			RegisterKafkaJobFunc: func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
// 				panic("mock out the RegisterKafkaJob method")
// 			},
// 			UpdateFunc: func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
// 				panic("mock out the Update method")
// 			},
// 			UpdateStatusFunc: func(id string, status constants2.KafkaStatus) (bool, *serviceError.ServiceError) {
// 				panic("mock out the UpdateStatus method")
// 			},
// 			UpdatesFunc: func(kafkaRequest *dbapi.KafkaRequest, values map[string]interface{}) *serviceError.ServiceError {
// 				panic("mock out the Updates method")
// 			},
// 			ValidateBillingAccountFunc: func(externalId string, instanceType types.KafkaInstanceType, billingCloudAccountId string, marketplace *string) *serviceError.ServiceError {
// 				panic("mock out the ValidateBillingAccount method")
// 			},
// 			VerifyAndUpdateKafkaAdminFunc: func(ctx context.Context, kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
// 				panic("mock out the VerifyAndUpdateKafkaAdmin method")
// 			},
// 		}
//
// 		// use mockedKafkaService in code that requires KafkaService
// 		// and then make assertions.
//
// 	}
type KafkaServiceMock struct {
	// AssignBootstrapServerHostFunc mocks the AssignBootstrapServerHost method.
	AssignBootstrapServerHostFunc func(kafkaRequest *dbapi.KafkaRequest) error

	// AssignInstanceTypeFunc mocks the AssignInstanceType method.
	AssignInstanceTypeFunc func(owner string, organisationID string) (types.KafkaInstanceType, *serviceError.ServiceError)

	// ChangeKafkaCNAMErecordsFunc mocks the ChangeKafkaCNAMErecords method.
	ChangeKafkaCNAMErecordsFunc func(kafkaRequest *dbapi.KafkaRequest, action KafkaRoutesAction) (*route53.ChangeResourceRecordSetsOutput, *serviceError.ServiceError)

	// CountByStatusFunc mocks the CountByStatus method.
	CountByStatusFunc func(status []constants2.KafkaStatus) ([]KafkaStatusCount, error)

	// CountStreamingUnitByRegionAndInstanceTypeFunc mocks the CountStreamingUnitByRegionAndInstanceType method.
	CountStreamingUnitByRegionAndInstanceTypeFunc func() ([]KafkaStreamingUnitCountPerRegion, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError

	// DeprovisionExpiredKafkasFunc mocks the DeprovisionExpiredKafkas method.
	DeprovisionExpiredKafkasFunc func() *serviceError.ServiceError

	// DeprovisionKafkaForUsersFunc mocks the DeprovisionKafkaForUsers method.
	DeprovisionKafkaForUsersFunc func(users []string) *serviceError.ServiceError

	// GenerateReservedManagedKafkasByClusterIDFunc mocks the GenerateReservedManagedKafkasByClusterID method.
	GenerateReservedManagedKafkasByClusterIDFunc func(clusterID string) ([]managedkafka.ManagedKafka, *serviceError.ServiceError)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id string) (*dbapi.KafkaRequest, *serviceError.ServiceError)

	// GetAvailableSizesInRegionFunc mocks the GetAvailableSizesInRegion method.
	GetAvailableSizesInRegionFunc func(criteria *FindClusterCriteria) ([]string, *serviceError.ServiceError)

	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(id string) (*dbapi.KafkaRequest, *serviceError.ServiceError)

	// GetCNAMERecordStatusFunc mocks the GetCNAMERecordStatus method.
	GetCNAMERecordStatusFunc func(kafkaRequest *dbapi.KafkaRequest) (*CNameRecordStatus, error)

	// GetManagedKafkaByClusterIDFunc mocks the GetManagedKafkaByClusterID method.
	GetManagedKafkaByClusterIDFunc func(clusterID string) ([]managedkafka.ManagedKafka, *serviceError.ServiceError)

	// HasAvailableCapacityInRegionFunc mocks the HasAvailableCapacityInRegion method.
	HasAvailableCapacityInRegionFunc func(kafkaRequest *dbapi.KafkaRequest) (bool, *serviceError.ServiceError)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, listArgs *services.ListArguments) (dbapi.KafkaList, *api.PagingMeta, *serviceError.ServiceError)

	// ListByStatusFunc mocks the ListByStatus method.
	ListByStatusFunc func(status ...constants2.KafkaStatus) ([]*dbapi.KafkaRequest, *serviceError.ServiceError)

	// ListComponentVersionsFunc mocks the ListComponentVersions method.
	ListComponentVersionsFunc func() ([]KafkaComponentVersions, error)

	// ListKafkasWithRoutesNotCreatedFunc mocks the ListKafkasWithRoutesNotCreated method.
	ListKafkasWithRoutesNotCreatedFunc func() ([]*dbapi.KafkaRequest, *serviceError.ServiceError)

	// PrepareKafkaRequestFunc mocks the PrepareKafkaRequest method.
	PrepareKafkaRequestFunc func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError

	// RegisterKafkaDeprovisionJobFunc mocks the RegisterKafkaDeprovisionJob method.
	RegisterKafkaDeprovisionJobFunc func(ctx context.Context, id string) *serviceError.ServiceError

	// RegisterKafkaJobFunc mocks the RegisterKafkaJob method.
	RegisterKafkaJobFunc func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError

	// UpdateFunc mocks the Update method.
	UpdateFunc func(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(id string, status constants2.KafkaStatus) (bool, *serviceError.ServiceError)

	// UpdatesFunc mocks the Updates method.
	UpdatesFunc func(kafkaRequest *dbapi.KafkaRequest, values map[string]interface{}) *serviceError.ServiceError

	// ValidateBillingAccountFunc mocks the ValidateBillingAccount method.
	ValidateBillingAccountFunc func(externalId string, instanceType types.KafkaInstanceType, billingCloudAccountId string, marketplace *string) *serviceError.ServiceError

	// VerifyAndUpdateKafkaAdminFunc mocks the VerifyAndUpdateKafkaAdmin method.
	VerifyAndUpdateKafkaAdminFunc func(ctx context.Context, kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError

	// calls tracks calls to the methods.
	calls struct {
		// AssignBootstrapServerHost holds details about calls to the AssignBootstrapServerHost method.
		AssignBootstrapServerHost []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// AssignInstanceType holds details about calls to the AssignInstanceType method.
		AssignInstanceType []struct {
			// Owner is the owner argument value.
			Owner string
			// OrganisationID is the organisationID argument value.
			OrganisationID string
		}
		// ChangeKafkaCNAMErecords holds details about calls to the ChangeKafkaCNAMErecords method.
		ChangeKafkaCNAMErecords []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
			// Action is the action argument value.
			Action KafkaRoutesAction
		}
		// CountByStatus holds details about calls to the CountByStatus method.
		CountByStatus []struct {
			// Status is the status argument value.
			Status []constants2.KafkaStatus
		}
		// CountStreamingUnitByRegionAndInstanceType holds details about calls to the CountStreamingUnitByRegionAndInstanceType method.
		CountStreamingUnitByRegionAndInstanceType []struct {
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// DeprovisionExpiredKafkas holds details about calls to the DeprovisionExpiredKafkas method.
		DeprovisionExpiredKafkas []struct {
		}
		// DeprovisionKafkaForUsers holds details about calls to the DeprovisionKafkaForUsers method.
		DeprovisionKafkaForUsers []struct {
			// Users is the users argument value.
			Users []string
		}
		// GenerateReservedManagedKafkasByClusterID holds details about calls to the GenerateReservedManagedKafkasByClusterID method.
		GenerateReservedManagedKafkasByClusterID []struct {
			// ClusterID is the clusterID argument value.
			ClusterID string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetAvailableSizesInRegion holds details about calls to the GetAvailableSizesInRegion method.
		GetAvailableSizesInRegion []struct {
			// Criteria is the criteria argument value.
			Criteria *FindClusterCriteria
		}
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// ID is the id argument value.
			ID string
		}
		// GetCNAMERecordStatus holds details about calls to the GetCNAMERecordStatus method.
		GetCNAMERecordStatus []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// GetManagedKafkaByClusterID holds details about calls to the GetManagedKafkaByClusterID method.
		GetManagedKafkaByClusterID []struct {
			// ClusterID is the clusterID argument value.
			ClusterID string
		}
		// HasAvailableCapacityInRegion holds details about calls to the HasAvailableCapacityInRegion method.
		HasAvailableCapacityInRegion []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ListArgs is the listArgs argument value.
			ListArgs *services.ListArguments
		}
		// ListByStatus holds details about calls to the ListByStatus method.
		ListByStatus []struct {
			// Status is the status argument value.
			Status []constants2.KafkaStatus
		}
		// ListComponentVersions holds details about calls to the ListComponentVersions method.
		ListComponentVersions []struct {
		}
		// ListKafkasWithRoutesNotCreated holds details about calls to the ListKafkasWithRoutesNotCreated method.
		ListKafkasWithRoutesNotCreated []struct {
		}
		// PrepareKafkaRequest holds details about calls to the PrepareKafkaRequest method.
		PrepareKafkaRequest []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// RegisterKafkaDeprovisionJob holds details about calls to the RegisterKafkaDeprovisionJob method.
		RegisterKafkaDeprovisionJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// RegisterKafkaJob holds details about calls to the RegisterKafkaJob method.
		RegisterKafkaJob []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// ID is the id argument value.
			ID string
			// Status is the status argument value.
			Status constants2.KafkaStatus
		}
		// Updates holds details about calls to the Updates method.
		Updates []struct {
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
			// Values is the values argument value.
			Values map[string]interface{}
		}
		// ValidateBillingAccount holds details about calls to the ValidateBillingAccount method.
		ValidateBillingAccount []struct {
			// ExternalId is the externalId argument value.
			ExternalId string
			// InstanceType is the instanceType argument value.
			InstanceType types.KafkaInstanceType
			// BillingCloudAccountId is the billingCloudAccountId argument value.
			BillingCloudAccountId string
			// Marketplace is the marketplace argument value.
			Marketplace *string
		}
		// VerifyAndUpdateKafkaAdmin holds details about calls to the VerifyAndUpdateKafkaAdmin method.
		VerifyAndUpdateKafkaAdmin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// KafkaRequest is the kafkaRequest argument value.
			KafkaRequest *dbapi.KafkaRequest
		}
	}
	lockAssignBootstrapServerHost                 sync.RWMutex
	lockAssignInstanceType                        sync.RWMutex
	lockChangeKafkaCNAMErecords                   sync.RWMutex
	lockCountByStatus                             sync.RWMutex
	lockCountStreamingUnitByRegionAndInstanceType sync.RWMutex
	lockDelete                                    sync.RWMutex
	lockDeprovisionExpiredKafkas                  sync.RWMutex
	lockDeprovisionKafkaForUsers                  sync.RWMutex
	lockGenerateReservedManagedKafkasByClusterID  sync.RWMutex
	lockGet                                       sync.RWMutex
	lockGetAvailableSizesInRegion                 sync.RWMutex
	lockGetById                                   sync.RWMutex
	lockGetCNAMERecordStatus                      sync.RWMutex
	lockGetManagedKafkaByClusterID                sync.RWMutex
	lockHasAvailableCapacityInRegion              sync.RWMutex
	lockList                                      sync.RWMutex
	lockListByStatus                              sync.RWMutex
	lockListComponentVersions                     sync.RWMutex
	lockListKafkasWithRoutesNotCreated            sync.RWMutex
	lockPrepareKafkaRequest                       sync.RWMutex
	lockRegisterKafkaDeprovisionJob               sync.RWMutex
	lockRegisterKafkaJob                          sync.RWMutex
	lockUpdate                                    sync.RWMutex
	lockUpdateStatus                              sync.RWMutex
	lockUpdates                                   sync.RWMutex
	lockValidateBillingAccount                    sync.RWMutex
	lockVerifyAndUpdateKafkaAdmin                 sync.RWMutex
}

// AssignBootstrapServerHost calls AssignBootstrapServerHostFunc.
func (mock *KafkaServiceMock) AssignBootstrapServerHost(kafkaRequest *dbapi.KafkaRequest) error {
	if mock.AssignBootstrapServerHostFunc == nil {
		panic("KafkaServiceMock.AssignBootstrapServerHostFunc: method is nil but KafkaService.AssignBootstrapServerHost was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockAssignBootstrapServerHost.Lock()
	mock.calls.AssignBootstrapServerHost = append(mock.calls.AssignBootstrapServerHost, callInfo)
	mock.lockAssignBootstrapServerHost.Unlock()
	return mock.AssignBootstrapServerHostFunc(kafkaRequest)
}

// AssignBootstrapServerHostCalls gets all the calls that were made to AssignBootstrapServerHost.
// Check the length with:
//     len(mockedKafkaService.AssignBootstrapServerHostCalls())
func (mock *KafkaServiceMock) AssignBootstrapServerHostCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockAssignBootstrapServerHost.RLock()
	calls = mock.calls.AssignBootstrapServerHost
	mock.lockAssignBootstrapServerHost.RUnlock()
	return calls
}

// AssignInstanceType calls AssignInstanceTypeFunc.
func (mock *KafkaServiceMock) AssignInstanceType(owner string, organisationID string) (types.KafkaInstanceType, *serviceError.ServiceError) {
	if mock.AssignInstanceTypeFunc == nil {
		panic("KafkaServiceMock.AssignInstanceTypeFunc: method is nil but KafkaService.AssignInstanceType was just called")
	}
	callInfo := struct {
		Owner          string
		OrganisationID string
	}{
		Owner:          owner,
		OrganisationID: organisationID,
	}
	mock.lockAssignInstanceType.Lock()
	mock.calls.AssignInstanceType = append(mock.calls.AssignInstanceType, callInfo)
	mock.lockAssignInstanceType.Unlock()
	return mock.AssignInstanceTypeFunc(owner, organisationID)
}

// AssignInstanceTypeCalls gets all the calls that were made to AssignInstanceType.
// Check the length with:
//     len(mockedKafkaService.AssignInstanceTypeCalls())
func (mock *KafkaServiceMock) AssignInstanceTypeCalls() []struct {
	Owner          string
	OrganisationID string
} {
	var calls []struct {
		Owner          string
		OrganisationID string
	}
	mock.lockAssignInstanceType.RLock()
	calls = mock.calls.AssignInstanceType
	mock.lockAssignInstanceType.RUnlock()
	return calls
}

// ChangeKafkaCNAMErecords calls ChangeKafkaCNAMErecordsFunc.
func (mock *KafkaServiceMock) ChangeKafkaCNAMErecords(kafkaRequest *dbapi.KafkaRequest, action KafkaRoutesAction) (*route53.ChangeResourceRecordSetsOutput, *serviceError.ServiceError) {
	if mock.ChangeKafkaCNAMErecordsFunc == nil {
		panic("KafkaServiceMock.ChangeKafkaCNAMErecordsFunc: method is nil but KafkaService.ChangeKafkaCNAMErecords was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
		Action       KafkaRoutesAction
	}{
		KafkaRequest: kafkaRequest,
		Action:       action,
	}
	mock.lockChangeKafkaCNAMErecords.Lock()
	mock.calls.ChangeKafkaCNAMErecords = append(mock.calls.ChangeKafkaCNAMErecords, callInfo)
	mock.lockChangeKafkaCNAMErecords.Unlock()
	return mock.ChangeKafkaCNAMErecordsFunc(kafkaRequest, action)
}

// ChangeKafkaCNAMErecordsCalls gets all the calls that were made to ChangeKafkaCNAMErecords.
// Check the length with:
//     len(mockedKafkaService.ChangeKafkaCNAMErecordsCalls())
func (mock *KafkaServiceMock) ChangeKafkaCNAMErecordsCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
	Action       KafkaRoutesAction
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
		Action       KafkaRoutesAction
	}
	mock.lockChangeKafkaCNAMErecords.RLock()
	calls = mock.calls.ChangeKafkaCNAMErecords
	mock.lockChangeKafkaCNAMErecords.RUnlock()
	return calls
}

// CountByStatus calls CountByStatusFunc.
func (mock *KafkaServiceMock) CountByStatus(status []constants2.KafkaStatus) ([]KafkaStatusCount, error) {
	if mock.CountByStatusFunc == nil {
		panic("KafkaServiceMock.CountByStatusFunc: method is nil but KafkaService.CountByStatus was just called")
	}
	callInfo := struct {
		Status []constants2.KafkaStatus
	}{
		Status: status,
	}
	mock.lockCountByStatus.Lock()
	mock.calls.CountByStatus = append(mock.calls.CountByStatus, callInfo)
	mock.lockCountByStatus.Unlock()
	return mock.CountByStatusFunc(status)
}

// CountByStatusCalls gets all the calls that were made to CountByStatus.
// Check the length with:
//     len(mockedKafkaService.CountByStatusCalls())
func (mock *KafkaServiceMock) CountByStatusCalls() []struct {
	Status []constants2.KafkaStatus
} {
	var calls []struct {
		Status []constants2.KafkaStatus
	}
	mock.lockCountByStatus.RLock()
	calls = mock.calls.CountByStatus
	mock.lockCountByStatus.RUnlock()
	return calls
}

// CountStreamingUnitByRegionAndInstanceType calls CountStreamingUnitByRegionAndInstanceTypeFunc.
func (mock *KafkaServiceMock) CountStreamingUnitByRegionAndInstanceType() ([]KafkaStreamingUnitCountPerRegion, error) {
	if mock.CountStreamingUnitByRegionAndInstanceTypeFunc == nil {
		panic("KafkaServiceMock.CountStreamingUnitByRegionAndInstanceTypeFunc: method is nil but KafkaService.CountStreamingUnitByRegionAndInstanceType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCountStreamingUnitByRegionAndInstanceType.Lock()
	mock.calls.CountStreamingUnitByRegionAndInstanceType = append(mock.calls.CountStreamingUnitByRegionAndInstanceType, callInfo)
	mock.lockCountStreamingUnitByRegionAndInstanceType.Unlock()
	return mock.CountStreamingUnitByRegionAndInstanceTypeFunc()
}

// CountStreamingUnitByRegionAndInstanceTypeCalls gets all the calls that were made to CountStreamingUnitByRegionAndInstanceType.
// Check the length with:
//     len(mockedKafkaService.CountStreamingUnitByRegionAndInstanceTypeCalls())
func (mock *KafkaServiceMock) CountStreamingUnitByRegionAndInstanceTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCountStreamingUnitByRegionAndInstanceType.RLock()
	calls = mock.calls.CountStreamingUnitByRegionAndInstanceType
	mock.lockCountStreamingUnitByRegionAndInstanceType.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KafkaServiceMock) Delete(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
	if mock.DeleteFunc == nil {
		panic("KafkaServiceMock.DeleteFunc: method is nil but KafkaService.Delete was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(kafkaRequest)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedKafkaService.DeleteCalls())
func (mock *KafkaServiceMock) DeleteCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeprovisionExpiredKafkas calls DeprovisionExpiredKafkasFunc.
func (mock *KafkaServiceMock) DeprovisionExpiredKafkas() *serviceError.ServiceError {
	if mock.DeprovisionExpiredKafkasFunc == nil {
		panic("KafkaServiceMock.DeprovisionExpiredKafkasFunc: method is nil but KafkaService.DeprovisionExpiredKafkas was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDeprovisionExpiredKafkas.Lock()
	mock.calls.DeprovisionExpiredKafkas = append(mock.calls.DeprovisionExpiredKafkas, callInfo)
	mock.lockDeprovisionExpiredKafkas.Unlock()
	return mock.DeprovisionExpiredKafkasFunc()
}

// DeprovisionExpiredKafkasCalls gets all the calls that were made to DeprovisionExpiredKafkas.
// Check the length with:
//     len(mockedKafkaService.DeprovisionExpiredKafkasCalls())
func (mock *KafkaServiceMock) DeprovisionExpiredKafkasCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDeprovisionExpiredKafkas.RLock()
	calls = mock.calls.DeprovisionExpiredKafkas
	mock.lockDeprovisionExpiredKafkas.RUnlock()
	return calls
}

// DeprovisionKafkaForUsers calls DeprovisionKafkaForUsersFunc.
func (mock *KafkaServiceMock) DeprovisionKafkaForUsers(users []string) *serviceError.ServiceError {
	if mock.DeprovisionKafkaForUsersFunc == nil {
		panic("KafkaServiceMock.DeprovisionKafkaForUsersFunc: method is nil but KafkaService.DeprovisionKafkaForUsers was just called")
	}
	callInfo := struct {
		Users []string
	}{
		Users: users,
	}
	mock.lockDeprovisionKafkaForUsers.Lock()
	mock.calls.DeprovisionKafkaForUsers = append(mock.calls.DeprovisionKafkaForUsers, callInfo)
	mock.lockDeprovisionKafkaForUsers.Unlock()
	return mock.DeprovisionKafkaForUsersFunc(users)
}

// DeprovisionKafkaForUsersCalls gets all the calls that were made to DeprovisionKafkaForUsers.
// Check the length with:
//     len(mockedKafkaService.DeprovisionKafkaForUsersCalls())
func (mock *KafkaServiceMock) DeprovisionKafkaForUsersCalls() []struct {
	Users []string
} {
	var calls []struct {
		Users []string
	}
	mock.lockDeprovisionKafkaForUsers.RLock()
	calls = mock.calls.DeprovisionKafkaForUsers
	mock.lockDeprovisionKafkaForUsers.RUnlock()
	return calls
}

// GenerateReservedManagedKafkasByClusterID calls GenerateReservedManagedKafkasByClusterIDFunc.
func (mock *KafkaServiceMock) GenerateReservedManagedKafkasByClusterID(clusterID string) ([]managedkafka.ManagedKafka, *serviceError.ServiceError) {
	if mock.GenerateReservedManagedKafkasByClusterIDFunc == nil {
		panic("KafkaServiceMock.GenerateReservedManagedKafkasByClusterIDFunc: method is nil but KafkaService.GenerateReservedManagedKafkasByClusterID was just called")
	}
	callInfo := struct {
		ClusterID string
	}{
		ClusterID: clusterID,
	}
	mock.lockGenerateReservedManagedKafkasByClusterID.Lock()
	mock.calls.GenerateReservedManagedKafkasByClusterID = append(mock.calls.GenerateReservedManagedKafkasByClusterID, callInfo)
	mock.lockGenerateReservedManagedKafkasByClusterID.Unlock()
	return mock.GenerateReservedManagedKafkasByClusterIDFunc(clusterID)
}

// GenerateReservedManagedKafkasByClusterIDCalls gets all the calls that were made to GenerateReservedManagedKafkasByClusterID.
// Check the length with:
//     len(mockedKafkaService.GenerateReservedManagedKafkasByClusterIDCalls())
func (mock *KafkaServiceMock) GenerateReservedManagedKafkasByClusterIDCalls() []struct {
	ClusterID string
} {
	var calls []struct {
		ClusterID string
	}
	mock.lockGenerateReservedManagedKafkasByClusterID.RLock()
	calls = mock.calls.GenerateReservedManagedKafkasByClusterID
	mock.lockGenerateReservedManagedKafkasByClusterID.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KafkaServiceMock) Get(ctx context.Context, id string) (*dbapi.KafkaRequest, *serviceError.ServiceError) {
	if mock.GetFunc == nil {
		panic("KafkaServiceMock.GetFunc: method is nil but KafkaService.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedKafkaService.GetCalls())
func (mock *KafkaServiceMock) GetCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAvailableSizesInRegion calls GetAvailableSizesInRegionFunc.
func (mock *KafkaServiceMock) GetAvailableSizesInRegion(criteria *FindClusterCriteria) ([]string, *serviceError.ServiceError) {
	if mock.GetAvailableSizesInRegionFunc == nil {
		panic("KafkaServiceMock.GetAvailableSizesInRegionFunc: method is nil but KafkaService.GetAvailableSizesInRegion was just called")
	}
	callInfo := struct {
		Criteria *FindClusterCriteria
	}{
		Criteria: criteria,
	}
	mock.lockGetAvailableSizesInRegion.Lock()
	mock.calls.GetAvailableSizesInRegion = append(mock.calls.GetAvailableSizesInRegion, callInfo)
	mock.lockGetAvailableSizesInRegion.Unlock()
	return mock.GetAvailableSizesInRegionFunc(criteria)
}

// GetAvailableSizesInRegionCalls gets all the calls that were made to GetAvailableSizesInRegion.
// Check the length with:
//     len(mockedKafkaService.GetAvailableSizesInRegionCalls())
func (mock *KafkaServiceMock) GetAvailableSizesInRegionCalls() []struct {
	Criteria *FindClusterCriteria
} {
	var calls []struct {
		Criteria *FindClusterCriteria
	}
	mock.lockGetAvailableSizesInRegion.RLock()
	calls = mock.calls.GetAvailableSizesInRegion
	mock.lockGetAvailableSizesInRegion.RUnlock()
	return calls
}

// GetById calls GetByIdFunc.
func (mock *KafkaServiceMock) GetById(id string) (*dbapi.KafkaRequest, *serviceError.ServiceError) {
	if mock.GetByIdFunc == nil {
		panic("KafkaServiceMock.GetByIdFunc: method is nil but KafkaService.GetById was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(id)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//     len(mockedKafkaService.GetByIdCalls())
func (mock *KafkaServiceMock) GetByIdCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}

// GetCNAMERecordStatus calls GetCNAMERecordStatusFunc.
func (mock *KafkaServiceMock) GetCNAMERecordStatus(kafkaRequest *dbapi.KafkaRequest) (*CNameRecordStatus, error) {
	if mock.GetCNAMERecordStatusFunc == nil {
		panic("KafkaServiceMock.GetCNAMERecordStatusFunc: method is nil but KafkaService.GetCNAMERecordStatus was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockGetCNAMERecordStatus.Lock()
	mock.calls.GetCNAMERecordStatus = append(mock.calls.GetCNAMERecordStatus, callInfo)
	mock.lockGetCNAMERecordStatus.Unlock()
	return mock.GetCNAMERecordStatusFunc(kafkaRequest)
}

// GetCNAMERecordStatusCalls gets all the calls that were made to GetCNAMERecordStatus.
// Check the length with:
//     len(mockedKafkaService.GetCNAMERecordStatusCalls())
func (mock *KafkaServiceMock) GetCNAMERecordStatusCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockGetCNAMERecordStatus.RLock()
	calls = mock.calls.GetCNAMERecordStatus
	mock.lockGetCNAMERecordStatus.RUnlock()
	return calls
}

// GetManagedKafkaByClusterID calls GetManagedKafkaByClusterIDFunc.
func (mock *KafkaServiceMock) GetManagedKafkaByClusterID(clusterID string) ([]managedkafka.ManagedKafka, *serviceError.ServiceError) {
	if mock.GetManagedKafkaByClusterIDFunc == nil {
		panic("KafkaServiceMock.GetManagedKafkaByClusterIDFunc: method is nil but KafkaService.GetManagedKafkaByClusterID was just called")
	}
	callInfo := struct {
		ClusterID string
	}{
		ClusterID: clusterID,
	}
	mock.lockGetManagedKafkaByClusterID.Lock()
	mock.calls.GetManagedKafkaByClusterID = append(mock.calls.GetManagedKafkaByClusterID, callInfo)
	mock.lockGetManagedKafkaByClusterID.Unlock()
	return mock.GetManagedKafkaByClusterIDFunc(clusterID)
}

// GetManagedKafkaByClusterIDCalls gets all the calls that were made to GetManagedKafkaByClusterID.
// Check the length with:
//     len(mockedKafkaService.GetManagedKafkaByClusterIDCalls())
func (mock *KafkaServiceMock) GetManagedKafkaByClusterIDCalls() []struct {
	ClusterID string
} {
	var calls []struct {
		ClusterID string
	}
	mock.lockGetManagedKafkaByClusterID.RLock()
	calls = mock.calls.GetManagedKafkaByClusterID
	mock.lockGetManagedKafkaByClusterID.RUnlock()
	return calls
}

// HasAvailableCapacityInRegion calls HasAvailableCapacityInRegionFunc.
func (mock *KafkaServiceMock) HasAvailableCapacityInRegion(kafkaRequest *dbapi.KafkaRequest) (bool, *serviceError.ServiceError) {
	if mock.HasAvailableCapacityInRegionFunc == nil {
		panic("KafkaServiceMock.HasAvailableCapacityInRegionFunc: method is nil but KafkaService.HasAvailableCapacityInRegion was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockHasAvailableCapacityInRegion.Lock()
	mock.calls.HasAvailableCapacityInRegion = append(mock.calls.HasAvailableCapacityInRegion, callInfo)
	mock.lockHasAvailableCapacityInRegion.Unlock()
	return mock.HasAvailableCapacityInRegionFunc(kafkaRequest)
}

// HasAvailableCapacityInRegionCalls gets all the calls that were made to HasAvailableCapacityInRegion.
// Check the length with:
//     len(mockedKafkaService.HasAvailableCapacityInRegionCalls())
func (mock *KafkaServiceMock) HasAvailableCapacityInRegionCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockHasAvailableCapacityInRegion.RLock()
	calls = mock.calls.HasAvailableCapacityInRegion
	mock.lockHasAvailableCapacityInRegion.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *KafkaServiceMock) List(ctx context.Context, listArgs *services.ListArguments) (dbapi.KafkaList, *api.PagingMeta, *serviceError.ServiceError) {
	if mock.ListFunc == nil {
		panic("KafkaServiceMock.ListFunc: method is nil but KafkaService.List was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ListArgs *services.ListArguments
	}{
		Ctx:      ctx,
		ListArgs: listArgs,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, listArgs)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedKafkaService.ListCalls())
func (mock *KafkaServiceMock) ListCalls() []struct {
	Ctx      context.Context
	ListArgs *services.ListArguments
} {
	var calls []struct {
		Ctx      context.Context
		ListArgs *services.ListArguments
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// ListByStatus calls ListByStatusFunc.
func (mock *KafkaServiceMock) ListByStatus(status ...constants2.KafkaStatus) ([]*dbapi.KafkaRequest, *serviceError.ServiceError) {
	if mock.ListByStatusFunc == nil {
		panic("KafkaServiceMock.ListByStatusFunc: method is nil but KafkaService.ListByStatus was just called")
	}
	callInfo := struct {
		Status []constants2.KafkaStatus
	}{
		Status: status,
	}
	mock.lockListByStatus.Lock()
	mock.calls.ListByStatus = append(mock.calls.ListByStatus, callInfo)
	mock.lockListByStatus.Unlock()
	return mock.ListByStatusFunc(status...)
}

// ListByStatusCalls gets all the calls that were made to ListByStatus.
// Check the length with:
//     len(mockedKafkaService.ListByStatusCalls())
func (mock *KafkaServiceMock) ListByStatusCalls() []struct {
	Status []constants2.KafkaStatus
} {
	var calls []struct {
		Status []constants2.KafkaStatus
	}
	mock.lockListByStatus.RLock()
	calls = mock.calls.ListByStatus
	mock.lockListByStatus.RUnlock()
	return calls
}

// ListComponentVersions calls ListComponentVersionsFunc.
func (mock *KafkaServiceMock) ListComponentVersions() ([]KafkaComponentVersions, error) {
	if mock.ListComponentVersionsFunc == nil {
		panic("KafkaServiceMock.ListComponentVersionsFunc: method is nil but KafkaService.ListComponentVersions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListComponentVersions.Lock()
	mock.calls.ListComponentVersions = append(mock.calls.ListComponentVersions, callInfo)
	mock.lockListComponentVersions.Unlock()
	return mock.ListComponentVersionsFunc()
}

// ListComponentVersionsCalls gets all the calls that were made to ListComponentVersions.
// Check the length with:
//     len(mockedKafkaService.ListComponentVersionsCalls())
func (mock *KafkaServiceMock) ListComponentVersionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListComponentVersions.RLock()
	calls = mock.calls.ListComponentVersions
	mock.lockListComponentVersions.RUnlock()
	return calls
}

// ListKafkasWithRoutesNotCreated calls ListKafkasWithRoutesNotCreatedFunc.
func (mock *KafkaServiceMock) ListKafkasWithRoutesNotCreated() ([]*dbapi.KafkaRequest, *serviceError.ServiceError) {
	if mock.ListKafkasWithRoutesNotCreatedFunc == nil {
		panic("KafkaServiceMock.ListKafkasWithRoutesNotCreatedFunc: method is nil but KafkaService.ListKafkasWithRoutesNotCreated was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListKafkasWithRoutesNotCreated.Lock()
	mock.calls.ListKafkasWithRoutesNotCreated = append(mock.calls.ListKafkasWithRoutesNotCreated, callInfo)
	mock.lockListKafkasWithRoutesNotCreated.Unlock()
	return mock.ListKafkasWithRoutesNotCreatedFunc()
}

// ListKafkasWithRoutesNotCreatedCalls gets all the calls that were made to ListKafkasWithRoutesNotCreated.
// Check the length with:
//     len(mockedKafkaService.ListKafkasWithRoutesNotCreatedCalls())
func (mock *KafkaServiceMock) ListKafkasWithRoutesNotCreatedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListKafkasWithRoutesNotCreated.RLock()
	calls = mock.calls.ListKafkasWithRoutesNotCreated
	mock.lockListKafkasWithRoutesNotCreated.RUnlock()
	return calls
}

// PrepareKafkaRequest calls PrepareKafkaRequestFunc.
func (mock *KafkaServiceMock) PrepareKafkaRequest(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
	if mock.PrepareKafkaRequestFunc == nil {
		panic("KafkaServiceMock.PrepareKafkaRequestFunc: method is nil but KafkaService.PrepareKafkaRequest was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockPrepareKafkaRequest.Lock()
	mock.calls.PrepareKafkaRequest = append(mock.calls.PrepareKafkaRequest, callInfo)
	mock.lockPrepareKafkaRequest.Unlock()
	return mock.PrepareKafkaRequestFunc(kafkaRequest)
}

// PrepareKafkaRequestCalls gets all the calls that were made to PrepareKafkaRequest.
// Check the length with:
//     len(mockedKafkaService.PrepareKafkaRequestCalls())
func (mock *KafkaServiceMock) PrepareKafkaRequestCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockPrepareKafkaRequest.RLock()
	calls = mock.calls.PrepareKafkaRequest
	mock.lockPrepareKafkaRequest.RUnlock()
	return calls
}

// RegisterKafkaDeprovisionJob calls RegisterKafkaDeprovisionJobFunc.
func (mock *KafkaServiceMock) RegisterKafkaDeprovisionJob(ctx context.Context, id string) *serviceError.ServiceError {
	if mock.RegisterKafkaDeprovisionJobFunc == nil {
		panic("KafkaServiceMock.RegisterKafkaDeprovisionJobFunc: method is nil but KafkaService.RegisterKafkaDeprovisionJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRegisterKafkaDeprovisionJob.Lock()
	mock.calls.RegisterKafkaDeprovisionJob = append(mock.calls.RegisterKafkaDeprovisionJob, callInfo)
	mock.lockRegisterKafkaDeprovisionJob.Unlock()
	return mock.RegisterKafkaDeprovisionJobFunc(ctx, id)
}

// RegisterKafkaDeprovisionJobCalls gets all the calls that were made to RegisterKafkaDeprovisionJob.
// Check the length with:
//     len(mockedKafkaService.RegisterKafkaDeprovisionJobCalls())
func (mock *KafkaServiceMock) RegisterKafkaDeprovisionJobCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockRegisterKafkaDeprovisionJob.RLock()
	calls = mock.calls.RegisterKafkaDeprovisionJob
	mock.lockRegisterKafkaDeprovisionJob.RUnlock()
	return calls
}

// RegisterKafkaJob calls RegisterKafkaJobFunc.
func (mock *KafkaServiceMock) RegisterKafkaJob(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
	if mock.RegisterKafkaJobFunc == nil {
		panic("KafkaServiceMock.RegisterKafkaJobFunc: method is nil but KafkaService.RegisterKafkaJob was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockRegisterKafkaJob.Lock()
	mock.calls.RegisterKafkaJob = append(mock.calls.RegisterKafkaJob, callInfo)
	mock.lockRegisterKafkaJob.Unlock()
	return mock.RegisterKafkaJobFunc(kafkaRequest)
}

// RegisterKafkaJobCalls gets all the calls that were made to RegisterKafkaJob.
// Check the length with:
//     len(mockedKafkaService.RegisterKafkaJobCalls())
func (mock *KafkaServiceMock) RegisterKafkaJobCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockRegisterKafkaJob.RLock()
	calls = mock.calls.RegisterKafkaJob
	mock.lockRegisterKafkaJob.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *KafkaServiceMock) Update(kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
	if mock.UpdateFunc == nil {
		panic("KafkaServiceMock.UpdateFunc: method is nil but KafkaService.Update was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
	}{
		KafkaRequest: kafkaRequest,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(kafkaRequest)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedKafkaService.UpdateCalls())
func (mock *KafkaServiceMock) UpdateCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *KafkaServiceMock) UpdateStatus(id string, status constants2.KafkaStatus) (bool, *serviceError.ServiceError) {
	if mock.UpdateStatusFunc == nil {
		panic("KafkaServiceMock.UpdateStatusFunc: method is nil but KafkaService.UpdateStatus was just called")
	}
	callInfo := struct {
		ID     string
		Status constants2.KafkaStatus
	}{
		ID:     id,
		Status: status,
	}
	mock.lockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	mock.lockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(id, status)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//     len(mockedKafkaService.UpdateStatusCalls())
func (mock *KafkaServiceMock) UpdateStatusCalls() []struct {
	ID     string
	Status constants2.KafkaStatus
} {
	var calls []struct {
		ID     string
		Status constants2.KafkaStatus
	}
	mock.lockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	mock.lockUpdateStatus.RUnlock()
	return calls
}

// Updates calls UpdatesFunc.
func (mock *KafkaServiceMock) Updates(kafkaRequest *dbapi.KafkaRequest, values map[string]interface{}) *serviceError.ServiceError {
	if mock.UpdatesFunc == nil {
		panic("KafkaServiceMock.UpdatesFunc: method is nil but KafkaService.Updates was just called")
	}
	callInfo := struct {
		KafkaRequest *dbapi.KafkaRequest
		Values       map[string]interface{}
	}{
		KafkaRequest: kafkaRequest,
		Values:       values,
	}
	mock.lockUpdates.Lock()
	mock.calls.Updates = append(mock.calls.Updates, callInfo)
	mock.lockUpdates.Unlock()
	return mock.UpdatesFunc(kafkaRequest, values)
}

// UpdatesCalls gets all the calls that were made to Updates.
// Check the length with:
//     len(mockedKafkaService.UpdatesCalls())
func (mock *KafkaServiceMock) UpdatesCalls() []struct {
	KafkaRequest *dbapi.KafkaRequest
	Values       map[string]interface{}
} {
	var calls []struct {
		KafkaRequest *dbapi.KafkaRequest
		Values       map[string]interface{}
	}
	mock.lockUpdates.RLock()
	calls = mock.calls.Updates
	mock.lockUpdates.RUnlock()
	return calls
}

// ValidateBillingAccount calls ValidateBillingAccountFunc.
func (mock *KafkaServiceMock) ValidateBillingAccount(externalId string, instanceType types.KafkaInstanceType, billingCloudAccountId string, marketplace *string) *serviceError.ServiceError {
	if mock.ValidateBillingAccountFunc == nil {
		panic("KafkaServiceMock.ValidateBillingAccountFunc: method is nil but KafkaService.ValidateBillingAccount was just called")
	}
	callInfo := struct {
		ExternalId            string
		InstanceType          types.KafkaInstanceType
		BillingCloudAccountId string
		Marketplace           *string
	}{
		ExternalId:            externalId,
		InstanceType:          instanceType,
		BillingCloudAccountId: billingCloudAccountId,
		Marketplace:           marketplace,
	}
	mock.lockValidateBillingAccount.Lock()
	mock.calls.ValidateBillingAccount = append(mock.calls.ValidateBillingAccount, callInfo)
	mock.lockValidateBillingAccount.Unlock()
	return mock.ValidateBillingAccountFunc(externalId, instanceType, billingCloudAccountId, marketplace)
}

// ValidateBillingAccountCalls gets all the calls that were made to ValidateBillingAccount.
// Check the length with:
//     len(mockedKafkaService.ValidateBillingAccountCalls())
func (mock *KafkaServiceMock) ValidateBillingAccountCalls() []struct {
	ExternalId            string
	InstanceType          types.KafkaInstanceType
	BillingCloudAccountId string
	Marketplace           *string
} {
	var calls []struct {
		ExternalId            string
		InstanceType          types.KafkaInstanceType
		BillingCloudAccountId string
		Marketplace           *string
	}
	mock.lockValidateBillingAccount.RLock()
	calls = mock.calls.ValidateBillingAccount
	mock.lockValidateBillingAccount.RUnlock()
	return calls
}

// VerifyAndUpdateKafkaAdmin calls VerifyAndUpdateKafkaAdminFunc.
func (mock *KafkaServiceMock) VerifyAndUpdateKafkaAdmin(ctx context.Context, kafkaRequest *dbapi.KafkaRequest) *serviceError.ServiceError {
	if mock.VerifyAndUpdateKafkaAdminFunc == nil {
		panic("KafkaServiceMock.VerifyAndUpdateKafkaAdminFunc: method is nil but KafkaService.VerifyAndUpdateKafkaAdmin was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		KafkaRequest *dbapi.KafkaRequest
	}{
		Ctx:          ctx,
		KafkaRequest: kafkaRequest,
	}
	mock.lockVerifyAndUpdateKafkaAdmin.Lock()
	mock.calls.VerifyAndUpdateKafkaAdmin = append(mock.calls.VerifyAndUpdateKafkaAdmin, callInfo)
	mock.lockVerifyAndUpdateKafkaAdmin.Unlock()
	return mock.VerifyAndUpdateKafkaAdminFunc(ctx, kafkaRequest)
}

// VerifyAndUpdateKafkaAdminCalls gets all the calls that were made to VerifyAndUpdateKafkaAdmin.
// Check the length with:
//     len(mockedKafkaService.VerifyAndUpdateKafkaAdminCalls())
func (mock *KafkaServiceMock) VerifyAndUpdateKafkaAdminCalls() []struct {
	Ctx          context.Context
	KafkaRequest *dbapi.KafkaRequest
} {
	var calls []struct {
		Ctx          context.Context
		KafkaRequest *dbapi.KafkaRequest
	}
	mock.lockVerifyAndUpdateKafkaAdmin.RLock()
	calls = mock.calls.VerifyAndUpdateKafkaAdmin
	mock.lockVerifyAndUpdateKafkaAdmin.RUnlock()
	return calls
}
