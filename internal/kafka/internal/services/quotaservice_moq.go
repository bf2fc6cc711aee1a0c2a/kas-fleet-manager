// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/api/dbapi"
	"github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/config"
	kafkaTypes "github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/internal/kafka/internal/kafkas/types"
	serviceError "github.com/bf2fc6cc711aee1a0c2a/kas-fleet-manager/pkg/errors"
	"sync"
)

// Ensure, that QuotaServiceMock does implement QuotaService.
// If this is not the case, regenerate this file with moq.
var _ QuotaService = &QuotaServiceMock{}

// QuotaServiceMock is a mock implementation of QuotaService.
//
//	func TestSomethingThatUsesQuotaService(t *testing.T) {
//
//		// make and configure a mocked QuotaService
//		mockedQuotaService := &QuotaServiceMock{
//			CheckIfQuotaIsDefinedForInstanceTypeFunc: func(username string, externalID string, instanceTypeID kafkaTypes.KafkaInstanceType, kafkaBillingModel config.KafkaBillingModel) (bool, *serviceError.ServiceError) {
//				panic("mock out the CheckIfQuotaIsDefinedForInstanceType method")
//			},
//			DeleteQuotaFunc: func(subscriptionId string) *serviceError.ServiceError {
//				panic("mock out the DeleteQuota method")
//			},
//			DeleteQuotaForBillingModelFunc: func(subscriptionId string, kafkaBillingModel config.KafkaBillingModel) *serviceError.ServiceError {
//				panic("mock out the DeleteQuotaForBillingModel method")
//			},
//			IsQuotaEntitlementActiveFunc: func(kafka *dbapi.KafkaRequest) (bool, error) {
//				panic("mock out the IsQuotaEntitlementActive method")
//			},
//			ReserveQuotaFunc: func(kafka *dbapi.KafkaRequest) (string, *serviceError.ServiceError) {
//				panic("mock out the ReserveQuota method")
//			},
//			ReserveQuotaIfNotAlreadyReservedFunc: func(kafka *dbapi.KafkaRequest) (string, *serviceError.ServiceError) {
//				panic("mock out the ReserveQuotaIfNotAlreadyReserved method")
//			},
//			ValidateBillingAccountFunc: func(organisationId string, instanceType kafkaTypes.KafkaInstanceType, billingModelID string, billingCloudAccountId string, marketplace *string) *serviceError.ServiceError {
//				panic("mock out the ValidateBillingAccount method")
//			},
//		}
//
//		// use mockedQuotaService in code that requires QuotaService
//		// and then make assertions.
//
//	}
type QuotaServiceMock struct {
	// CheckIfQuotaIsDefinedForInstanceTypeFunc mocks the CheckIfQuotaIsDefinedForInstanceType method.
	CheckIfQuotaIsDefinedForInstanceTypeFunc func(username string, externalID string, instanceTypeID kafkaTypes.KafkaInstanceType, kafkaBillingModel config.KafkaBillingModel) (bool, *serviceError.ServiceError)

	// DeleteQuotaFunc mocks the DeleteQuota method.
	DeleteQuotaFunc func(subscriptionId string) *serviceError.ServiceError

	// DeleteQuotaForBillingModelFunc mocks the DeleteQuotaForBillingModel method.
	DeleteQuotaForBillingModelFunc func(subscriptionId string, kafkaBillingModel config.KafkaBillingModel) *serviceError.ServiceError

	// IsQuotaEntitlementActiveFunc mocks the IsQuotaEntitlementActive method.
	IsQuotaEntitlementActiveFunc func(kafka *dbapi.KafkaRequest) (bool, error)

	// ReserveQuotaFunc mocks the ReserveQuota method.
	ReserveQuotaFunc func(kafka *dbapi.KafkaRequest) (string, *serviceError.ServiceError)

	// ReserveQuotaIfNotAlreadyReservedFunc mocks the ReserveQuotaIfNotAlreadyReserved method.
	ReserveQuotaIfNotAlreadyReservedFunc func(kafka *dbapi.KafkaRequest) (string, *serviceError.ServiceError)

	// ValidateBillingAccountFunc mocks the ValidateBillingAccount method.
	ValidateBillingAccountFunc func(organisationId string, instanceType kafkaTypes.KafkaInstanceType, billingModelID string, billingCloudAccountId string, marketplace *string) *serviceError.ServiceError

	// calls tracks calls to the methods.
	calls struct {
		// CheckIfQuotaIsDefinedForInstanceType holds details about calls to the CheckIfQuotaIsDefinedForInstanceType method.
		CheckIfQuotaIsDefinedForInstanceType []struct {
			// Username is the username argument value.
			Username string
			// ExternalID is the externalID argument value.
			ExternalID string
			// InstanceTypeID is the instanceTypeID argument value.
			InstanceTypeID kafkaTypes.KafkaInstanceType
			// KafkaBillingModel is the kafkaBillingModel argument value.
			KafkaBillingModel config.KafkaBillingModel
		}
		// DeleteQuota holds details about calls to the DeleteQuota method.
		DeleteQuota []struct {
			// SubscriptionId is the subscriptionId argument value.
			SubscriptionId string
		}
		// DeleteQuotaForBillingModel holds details about calls to the DeleteQuotaForBillingModel method.
		DeleteQuotaForBillingModel []struct {
			// SubscriptionId is the subscriptionId argument value.
			SubscriptionId string
			// KafkaBillingModel is the kafkaBillingModel argument value.
			KafkaBillingModel config.KafkaBillingModel
		}
		// IsQuotaEntitlementActive holds details about calls to the IsQuotaEntitlementActive method.
		IsQuotaEntitlementActive []struct {
			// Kafka is the kafka argument value.
			Kafka *dbapi.KafkaRequest
		}
		// ReserveQuota holds details about calls to the ReserveQuota method.
		ReserveQuota []struct {
			// Kafka is the kafka argument value.
			Kafka *dbapi.KafkaRequest
		}
		// ReserveQuotaIfNotAlreadyReserved holds details about calls to the ReserveQuotaIfNotAlreadyReserved method.
		ReserveQuotaIfNotAlreadyReserved []struct {
			// Kafka is the kafka argument value.
			Kafka *dbapi.KafkaRequest
		}
		// ValidateBillingAccount holds details about calls to the ValidateBillingAccount method.
		ValidateBillingAccount []struct {
			// OrganisationId is the organisationId argument value.
			OrganisationId string
			// InstanceType is the instanceType argument value.
			InstanceType kafkaTypes.KafkaInstanceType
			// BillingModelID is the billingModelID argument value.
			BillingModelID string
			// BillingCloudAccountId is the billingCloudAccountId argument value.
			BillingCloudAccountId string
			// Marketplace is the marketplace argument value.
			Marketplace *string
		}
	}
	lockCheckIfQuotaIsDefinedForInstanceType sync.RWMutex
	lockDeleteQuota                          sync.RWMutex
	lockDeleteQuotaForBillingModel           sync.RWMutex
	lockIsQuotaEntitlementActive             sync.RWMutex
	lockReserveQuota                         sync.RWMutex
	lockReserveQuotaIfNotAlreadyReserved     sync.RWMutex
	lockValidateBillingAccount               sync.RWMutex
}

// CheckIfQuotaIsDefinedForInstanceType calls CheckIfQuotaIsDefinedForInstanceTypeFunc.
func (mock *QuotaServiceMock) CheckIfQuotaIsDefinedForInstanceType(username string, externalID string, instanceTypeID kafkaTypes.KafkaInstanceType, kafkaBillingModel config.KafkaBillingModel) (bool, *serviceError.ServiceError) {
	if mock.CheckIfQuotaIsDefinedForInstanceTypeFunc == nil {
		panic("QuotaServiceMock.CheckIfQuotaIsDefinedForInstanceTypeFunc: method is nil but QuotaService.CheckIfQuotaIsDefinedForInstanceType was just called")
	}
	callInfo := struct {
		Username          string
		ExternalID        string
		InstanceTypeID    kafkaTypes.KafkaInstanceType
		KafkaBillingModel config.KafkaBillingModel
	}{
		Username:          username,
		ExternalID:        externalID,
		InstanceTypeID:    instanceTypeID,
		KafkaBillingModel: kafkaBillingModel,
	}
	mock.lockCheckIfQuotaIsDefinedForInstanceType.Lock()
	mock.calls.CheckIfQuotaIsDefinedForInstanceType = append(mock.calls.CheckIfQuotaIsDefinedForInstanceType, callInfo)
	mock.lockCheckIfQuotaIsDefinedForInstanceType.Unlock()
	return mock.CheckIfQuotaIsDefinedForInstanceTypeFunc(username, externalID, instanceTypeID, kafkaBillingModel)
}

// CheckIfQuotaIsDefinedForInstanceTypeCalls gets all the calls that were made to CheckIfQuotaIsDefinedForInstanceType.
// Check the length with:
//
//	len(mockedQuotaService.CheckIfQuotaIsDefinedForInstanceTypeCalls())
func (mock *QuotaServiceMock) CheckIfQuotaIsDefinedForInstanceTypeCalls() []struct {
	Username          string
	ExternalID        string
	InstanceTypeID    kafkaTypes.KafkaInstanceType
	KafkaBillingModel config.KafkaBillingModel
} {
	var calls []struct {
		Username          string
		ExternalID        string
		InstanceTypeID    kafkaTypes.KafkaInstanceType
		KafkaBillingModel config.KafkaBillingModel
	}
	mock.lockCheckIfQuotaIsDefinedForInstanceType.RLock()
	calls = mock.calls.CheckIfQuotaIsDefinedForInstanceType
	mock.lockCheckIfQuotaIsDefinedForInstanceType.RUnlock()
	return calls
}

// DeleteQuota calls DeleteQuotaFunc.
func (mock *QuotaServiceMock) DeleteQuota(subscriptionId string) *serviceError.ServiceError {
	if mock.DeleteQuotaFunc == nil {
		panic("QuotaServiceMock.DeleteQuotaFunc: method is nil but QuotaService.DeleteQuota was just called")
	}
	callInfo := struct {
		SubscriptionId string
	}{
		SubscriptionId: subscriptionId,
	}
	mock.lockDeleteQuota.Lock()
	mock.calls.DeleteQuota = append(mock.calls.DeleteQuota, callInfo)
	mock.lockDeleteQuota.Unlock()
	return mock.DeleteQuotaFunc(subscriptionId)
}

// DeleteQuotaCalls gets all the calls that were made to DeleteQuota.
// Check the length with:
//
//	len(mockedQuotaService.DeleteQuotaCalls())
func (mock *QuotaServiceMock) DeleteQuotaCalls() []struct {
	SubscriptionId string
} {
	var calls []struct {
		SubscriptionId string
	}
	mock.lockDeleteQuota.RLock()
	calls = mock.calls.DeleteQuota
	mock.lockDeleteQuota.RUnlock()
	return calls
}

// DeleteQuotaForBillingModel calls DeleteQuotaForBillingModelFunc.
func (mock *QuotaServiceMock) DeleteQuotaForBillingModel(subscriptionId string, kafkaBillingModel config.KafkaBillingModel) *serviceError.ServiceError {
	if mock.DeleteQuotaForBillingModelFunc == nil {
		panic("QuotaServiceMock.DeleteQuotaForBillingModelFunc: method is nil but QuotaService.DeleteQuotaForBillingModel was just called")
	}
	callInfo := struct {
		SubscriptionId    string
		KafkaBillingModel config.KafkaBillingModel
	}{
		SubscriptionId:    subscriptionId,
		KafkaBillingModel: kafkaBillingModel,
	}
	mock.lockDeleteQuotaForBillingModel.Lock()
	mock.calls.DeleteQuotaForBillingModel = append(mock.calls.DeleteQuotaForBillingModel, callInfo)
	mock.lockDeleteQuotaForBillingModel.Unlock()
	return mock.DeleteQuotaForBillingModelFunc(subscriptionId, kafkaBillingModel)
}

// DeleteQuotaForBillingModelCalls gets all the calls that were made to DeleteQuotaForBillingModel.
// Check the length with:
//
//	len(mockedQuotaService.DeleteQuotaForBillingModelCalls())
func (mock *QuotaServiceMock) DeleteQuotaForBillingModelCalls() []struct {
	SubscriptionId    string
	KafkaBillingModel config.KafkaBillingModel
} {
	var calls []struct {
		SubscriptionId    string
		KafkaBillingModel config.KafkaBillingModel
	}
	mock.lockDeleteQuotaForBillingModel.RLock()
	calls = mock.calls.DeleteQuotaForBillingModel
	mock.lockDeleteQuotaForBillingModel.RUnlock()
	return calls
}

// IsQuotaEntitlementActive calls IsQuotaEntitlementActiveFunc.
func (mock *QuotaServiceMock) IsQuotaEntitlementActive(kafka *dbapi.KafkaRequest) (bool, error) {
	if mock.IsQuotaEntitlementActiveFunc == nil {
		panic("QuotaServiceMock.IsQuotaEntitlementActiveFunc: method is nil but QuotaService.IsQuotaEntitlementActive was just called")
	}
	callInfo := struct {
		Kafka *dbapi.KafkaRequest
	}{
		Kafka: kafka,
	}
	mock.lockIsQuotaEntitlementActive.Lock()
	mock.calls.IsQuotaEntitlementActive = append(mock.calls.IsQuotaEntitlementActive, callInfo)
	mock.lockIsQuotaEntitlementActive.Unlock()
	return mock.IsQuotaEntitlementActiveFunc(kafka)
}

// IsQuotaEntitlementActiveCalls gets all the calls that were made to IsQuotaEntitlementActive.
// Check the length with:
//
//	len(mockedQuotaService.IsQuotaEntitlementActiveCalls())
func (mock *QuotaServiceMock) IsQuotaEntitlementActiveCalls() []struct {
	Kafka *dbapi.KafkaRequest
} {
	var calls []struct {
		Kafka *dbapi.KafkaRequest
	}
	mock.lockIsQuotaEntitlementActive.RLock()
	calls = mock.calls.IsQuotaEntitlementActive
	mock.lockIsQuotaEntitlementActive.RUnlock()
	return calls
}

// ReserveQuota calls ReserveQuotaFunc.
func (mock *QuotaServiceMock) ReserveQuota(kafka *dbapi.KafkaRequest) (string, *serviceError.ServiceError) {
	if mock.ReserveQuotaFunc == nil {
		panic("QuotaServiceMock.ReserveQuotaFunc: method is nil but QuotaService.ReserveQuota was just called")
	}
	callInfo := struct {
		Kafka *dbapi.KafkaRequest
	}{
		Kafka: kafka,
	}
	mock.lockReserveQuota.Lock()
	mock.calls.ReserveQuota = append(mock.calls.ReserveQuota, callInfo)
	mock.lockReserveQuota.Unlock()
	return mock.ReserveQuotaFunc(kafka)
}

// ReserveQuotaCalls gets all the calls that were made to ReserveQuota.
// Check the length with:
//
//	len(mockedQuotaService.ReserveQuotaCalls())
func (mock *QuotaServiceMock) ReserveQuotaCalls() []struct {
	Kafka *dbapi.KafkaRequest
} {
	var calls []struct {
		Kafka *dbapi.KafkaRequest
	}
	mock.lockReserveQuota.RLock()
	calls = mock.calls.ReserveQuota
	mock.lockReserveQuota.RUnlock()
	return calls
}

// ReserveQuotaIfNotAlreadyReserved calls ReserveQuotaIfNotAlreadyReservedFunc.
func (mock *QuotaServiceMock) ReserveQuotaIfNotAlreadyReserved(kafka *dbapi.KafkaRequest) (string, *serviceError.ServiceError) {
	if mock.ReserveQuotaIfNotAlreadyReservedFunc == nil {
		panic("QuotaServiceMock.ReserveQuotaIfNotAlreadyReservedFunc: method is nil but QuotaService.ReserveQuotaIfNotAlreadyReserved was just called")
	}
	callInfo := struct {
		Kafka *dbapi.KafkaRequest
	}{
		Kafka: kafka,
	}
	mock.lockReserveQuotaIfNotAlreadyReserved.Lock()
	mock.calls.ReserveQuotaIfNotAlreadyReserved = append(mock.calls.ReserveQuotaIfNotAlreadyReserved, callInfo)
	mock.lockReserveQuotaIfNotAlreadyReserved.Unlock()
	return mock.ReserveQuotaIfNotAlreadyReservedFunc(kafka)
}

// ReserveQuotaIfNotAlreadyReservedCalls gets all the calls that were made to ReserveQuotaIfNotAlreadyReserved.
// Check the length with:
//
//	len(mockedQuotaService.ReserveQuotaIfNotAlreadyReservedCalls())
func (mock *QuotaServiceMock) ReserveQuotaIfNotAlreadyReservedCalls() []struct {
	Kafka *dbapi.KafkaRequest
} {
	var calls []struct {
		Kafka *dbapi.KafkaRequest
	}
	mock.lockReserveQuotaIfNotAlreadyReserved.RLock()
	calls = mock.calls.ReserveQuotaIfNotAlreadyReserved
	mock.lockReserveQuotaIfNotAlreadyReserved.RUnlock()
	return calls
}

// ValidateBillingAccount calls ValidateBillingAccountFunc.
func (mock *QuotaServiceMock) ValidateBillingAccount(organisationId string, instanceType kafkaTypes.KafkaInstanceType, billingModelID string, billingCloudAccountId string, marketplace *string) *serviceError.ServiceError {
	if mock.ValidateBillingAccountFunc == nil {
		panic("QuotaServiceMock.ValidateBillingAccountFunc: method is nil but QuotaService.ValidateBillingAccount was just called")
	}
	callInfo := struct {
		OrganisationId        string
		InstanceType          kafkaTypes.KafkaInstanceType
		BillingModelID        string
		BillingCloudAccountId string
		Marketplace           *string
	}{
		OrganisationId:        organisationId,
		InstanceType:          instanceType,
		BillingModelID:        billingModelID,
		BillingCloudAccountId: billingCloudAccountId,
		Marketplace:           marketplace,
	}
	mock.lockValidateBillingAccount.Lock()
	mock.calls.ValidateBillingAccount = append(mock.calls.ValidateBillingAccount, callInfo)
	mock.lockValidateBillingAccount.Unlock()
	return mock.ValidateBillingAccountFunc(organisationId, instanceType, billingModelID, billingCloudAccountId, marketplace)
}

// ValidateBillingAccountCalls gets all the calls that were made to ValidateBillingAccount.
// Check the length with:
//
//	len(mockedQuotaService.ValidateBillingAccountCalls())
func (mock *QuotaServiceMock) ValidateBillingAccountCalls() []struct {
	OrganisationId        string
	InstanceType          kafkaTypes.KafkaInstanceType
	BillingModelID        string
	BillingCloudAccountId string
	Marketplace           *string
} {
	var calls []struct {
		OrganisationId        string
		InstanceType          kafkaTypes.KafkaInstanceType
		BillingModelID        string
		BillingCloudAccountId string
		Marketplace           *string
	}
	mock.lockValidateBillingAccount.RLock()
	calls = mock.calls.ValidateBillingAccount
	mock.lockValidateBillingAccount.RUnlock()
	return calls
}
